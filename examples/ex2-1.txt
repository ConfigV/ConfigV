
#############################################
#
# My own version of two config files (learning set)
# that have all the (corrected) errors we are interested in
#
#############################################

LEARNING SET FILE #1

A02  InitiatorName = iqn:dev_domain
A03  
A05  include schema/ppolicy.schema
A06  overlay ppolicy
A07
A10  extension = mysql.so
A11  extension = recode.so
A12
A16  NameVirtualHost *:80
A17  <VirtualHost *:80>
A18  </VirtualHost>
A19
A22  max_connection = 300
A23  mysql.max_persistent = 300
----------------------------------------

LEARNING SET FILE #2

B01  include schema/ppolicy.schema
B02  extension = mysql.so
B03  extension = recode.so
B04  InitiatorName = iqn:dev_domain
B05  overlay ppolicy
B06  NameVirtualHost *:70
B07  <VirtualHost *:70>
B08  </VirtualHost>
B09  max_connection = 400
B10  mysql.max_persistent = 300

----------------------------------------

USER INPUT FILE (with errors that need to be identified)

C01  InitiatorName = iqn:DEV_domain (only lower case allowed)
C02  # overlay ppolicy (missing include)
C03  # extension = recode.so
C04  # extension = mysql.so
C05  # NameVirtualHost *:80
C06  # <VirtualHost *>
C07  # </VirtualHost>
C08  # max_connection = 300
C09  # mysql.max_persistent = 400
#############################################
 
 How to learn value ordering constraints
 a var, val pair order
1) collect ordering on every line for every file in learning set (LS)
2) intersect orders that are preserved over LS

intersect(
  (A02,A05) /\ (A02,A06) /\ ...
  (A05,A06) /\ (A05,A10)

  (B01,B02) /\ (B01,B03) /\ ..
)
=>
  (B01,B05) /\
  (B02,B03) /\
  (B07,B08) /\
  (B08,B09) /\
  (B09,B10)

----------------------------------------

  to learn block structures like ite, add variable ordering constraints

----------------------------------------
 
 How to learn value relation constaints 
1) seperate values by type
  1a) types are user supplied (or predefined) regexs (made with PBE?) 
      (e.g. Type IP = \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}, Type File = *.*)
  1b) anything to the right of a '=' (or ' ' maybe) is also a value
  1c) every type has comparison operators
      instance IP Ord where 
        ip1 <= ip2 = 

      class TightCompare a where
        tightest :: a -> a -> Clause a
      instance IP TightCompare where
        tightest ip1 ip2 = 

      data Clause a = 
2) v(A22)


 
