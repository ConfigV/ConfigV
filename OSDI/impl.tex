\section{Implementation}

\app is primarily implemented in Haskell, and the suspicious values
detection module was written in R. 
%The suspicious value module reimplements the
%main functionality of the Haskell system, and is is a testament to the
%simplicity of the algorithm and the ease of reproduction. 
For clarity,
we only present the key components of the Haskell implementation here.

The translator is developed as a parser for the grammar
described in $\S$\ref{sec-trans}. 
%The implementation presented no interesting challenges. 

The learning and checking modules are developed to allow
for customized extensibility. In order to verify a configuration file
against a new type of error, a user only needs to provide a new type
that is an instance of the \textit{Attribute} typeclass (\ie, define some
functions over that type). 
In particular, for each type of error the users
wish to detect, they must implement three functions;
\lstinline{learn}, \lstinline{merge}, and \lstinline{check}.

\com{
\begin{lstlisting}
class Foldable t => RuleSet t a where
  learn :: IRConfigFile -> t a
  merge :: t a -> t a -> t a
  check :: t a -> IRConfigFile -> [Error]
\end{lstlisting}

This typeclass is polymorphic over the data structure as denoted by 
\lstinline{Foldable t =>}, 
which means user can choose any data structure they prefer.
In general, the best data structure is a hashmap 
from key-value pairs to relations, 
previously defined as a \textit{P\_Rule} in $\S$\ref{subsec-rules}.
}

The \lstinline{learn} function takes the intermediate representation of 
a single configuration file (as generated by the translator), 
and generates the set of rules that can be derived from that file.
Specifically, these rules take the form of 
a \textit{P\_Rule} to track the counts of relation events.
The \lstinline{merge} function will unify two sets of rules, from two separate configuration files, into a single consistent set of rules. 
For the probabilistic rules, this tends to be simply a union between the two sets. 
When two equivalent rules are merged, the relation event counts should be summed to update the probability distributions.

The \lstinline{check} function will start all the rules we have learned, 
and filter until we only have the rules that have been broken by the file 
of interest. We first eliminate the rules 
that do not pass the probability check defined in $\S$\ref{subsec-rules}.
Second, we only consider the rules which are relevant to the file -- we 
do not need to check rules about the entries 
that do not appear in the file.
Lastly, we take the errors 
as any rule that does not hold over the given file.


\com{
A sketch of a typical implementation of these three functions is shown below. Again, the specifics of this implementation will vary based on the type of error being detected. 

\begin{lstlisting}
learn f = 
  count_relation_events (all_line_pairs f)
merge s1 s2 = 
  unionWith sum s1 s2
check rs f = 
  likely_rs  = filter prob_check rs
  related_rs = filter applies_to_file likely_rs
  errors_rs  = filter (is_valid f) related_rs
 in errors
\end{lstlisting}
}

%The rest of the system is structural code to handle these modules for the user. 
The core learning algorithm will learn over each file individually, 
then merge the results of learning together. 
Since we learn each set of rules on each file in isolation from the others, we have a pleasingly parallel situation.
The \lstinline{learn} function can then be called in parallel over the entire learning set.
As a functional language, there is no programming overhead to implement
this in Haskell -- we simply import the parallel mapping library \cite{parallel} to replace all uses of  \lstinline{map} with \lstinline{parmap}.
The merge stage could also be parallelized by using a divide and conquer approach, but this is not a priority since the learning stage only needs to be run once per learning set, and can then be cached (in our case, as a .json file) for fast reading when doing verification.

The source code for our implementation is available at {\em (URL omitted for blind review)}.
