
\section{Translator}
\label{sec-trans}

The translator takes as input a sample dataset of configuration files and transforms a given sample
dataset of configuration files into another set of files written in
typed and well-structured representations.
The translator can be seen a parser, and it is only
used to generate an intermediate representation for the post
process, such as learning rules (see $\S$\ref{sec-learn}).
Coupled with rules generated by learner module,
we will have a complete language model to verify configuration files
of our interest.

Translating or parsing is system dependent. In other words, for MySQL
and HDFS, we need to develop different parsers to handle each of them,
respectively. \app also allows users to 
provide extra help to the translator
for their specific system configurations,
but not necessarily. 
Each of the entries in the intermediate representations
have been assigned types, and these types guide the learning
modules later.


\para{Probabilistic types.}
For any key-value entry in the sample configuration files,
the translator cannot fully determine the type of key 
based on a single example value.
Consider the following example.

\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
foo = 300
bar = 300.txt
\end{lstlisting} 

Most likely {\tt foo} should be an integer, but it could also be a string.
In this case, we want to learn the rule like 
$ \texttt{foo} \in \textsf{substrings}(\texttt{bar})$. 
The translator, therefore, assigns a distribution of types 
to a value, an idea closely related to existentially quantified 
types~\cite{Launchbury93lazyfunctional}. 
We introduce {\em probabilistic types} to address this issue.

Let $\mathcal{T}$ be a set of basic types. 
In \app set $\mathcal{T}$ contains strings, integers, file paths, 
sizes and IP addresses. 
A probabilistic type built from $\mathcal{T}$ is a list of pairs 
$[(\tau_1, p_1),\ldots,(\tau_n, p_n)]$,
such that $\tau_i \in \mathcal{T}$, $0 \le p_i \le 1$ 
and $\Sigma p_i = 1$. 
These probabilities are updated each time a new example value 
for a key is encountered.

When a value has a probabilistic type, we generate rules for all its types.
This means that by assigning {\texttt{foo}} a probabilistic type 
(\eg, {\tt (\texttt{foo}, 300, [(\textsl{Int},90\%), 
(\textsl{String},10\%)])},
we would generate rules for both strings and integers.
Once the type inference can uniquely determine the type, 
the probability of all other types is set to zero, 
and the associated rules are withdrawn.

\para{Formal Intermediate Representation.}
The formal grammar we use for our intermediate representation presented in the following. 
Firstly, we make a list of the possible types for a configuration file. This is present in 
Secondly, we 

\begin{table}
  \begin{tabular}{| l | c | r |}
    \hline
    Type & Operation & 3 \\ \hline
    4 & 5 & 6 \\ \hline
    7 & 8 & 9 \\
    \hline
  \end{tabular}
\caption{Table of Types Along with Operation Pools}
\label{table:kysymys}
\end{table}

We come up with the following types:

1. Port 
The $i$-th entry inside an intermediate representation corresponding to a 
translated file 

We declare a quadruple $(g,k,v,\{\tau_1, \ldots, \tau_n\}_i$
We need a kind of formal definition (using a figure) to
define the grammar of our intermediate representation. The basic
view of this definition should be similar to define a type language
grammar.


\com{Note that typing is also a system module than 
can be easily extended to support more types. 
In that case the user will need to provide rules for type inference 
and probability distributions for values where type inference is ambiguous.
}
