
\section{Translator}
\label{sec-trans}

The responsibility of the translator is to transform a given set of
configuration files into another set of files written in
typed and well-structured representations.
In some sense, the translator looks like a parser, and it is only
used to generate an intermediate representation for the post
process, such as learning rules (see $\S$\ref{sec-learn}).
Coupled with rules generated by learner module,
we will have a complete language model to verify configuration files
of our interest.

Translating or parsing is system dependent. In other words, for MySQL
and HDFS, we need to develop different parsers to handle each of them,
respectively. \app allows users to provide extra help to the translator
for their specific system configuration, such as specifying a comment 
character. Each of the entries in the intermediate representations
must be assigned types, and these types would guide the learning
modules later.

\ennan{We need a kind of formal definition (using a figure) to
define the grammar of our intermediate representation. The basic
view of this definition should be similar to define a type language
grammar.}

\para{Introducing probabilistic types.}
Based on a single example value of $v$,
the translator cannot fully determine the type of $k$.
Consider for instance the following example:

\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
foo = 300
bar = 300.txt
\end{lstlisting} 

Most likely {\tt foo} should be an integer, but it could also be a string.
In this case, we want to learn the rule like 
$ \texttt{foo} \in \textsf{substrings}(\texttt{bar})$. 
The translator, therefore, assigns a distribution of types 
to a value, an idea closely related to existentially quantified 
types~\cite{Launchbury93lazyfunctional}. 
We introduce {\em probabilistic types} to address this issue.

Let $\mathcal{T}$ be a set of basic types. 
In \app set $\mathcal{T}$ contains strings, integers, file paths, 
sizes and IP addresses. 
A probabilistic type built from $\mathcal{T}$ is a list of pairs 
$[(\tau_1, p_1),\ldots,(\tau_n, p_n)]$,
such that $\tau_i \in \mathcal{T}$, $0 \le p_i \le 1$ 
and $\Sigma p_i = 1$. 
These probabilities are updated each time a new example value 
for a key is encountered.

When a value has a probabilistic type, we generate rules for all its types.
This means that by assigning {\texttt{foo}} a probabilistic type 
(\eg, {\tt (\texttt{foo}, 300, [(\textsl{Int},90\%), 
(\textsl{String},10\%)])},
we would generate rules for both strings and integers.
Once the type inference can uniquely determine the type, 
the probability of all other types is set to zero, 
and the associated rules are withdrawn.

Note that typing is also a system module than 
can be easily extended to support more types. 
In that case the user will need to provide rules for type inference 
and probability distributions for values where type inference is ambiguous.

