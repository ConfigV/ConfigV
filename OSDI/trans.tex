
\section{Translator}
\label{sec-trans}

The translator takes as input a sample dataset of configuration files and transforms it into another set of files written in
typed and well-structured representations.
The translator can be seen a parser, and it is only
used to generate an intermediate representation for the post
process, such as learning rules (see $\S$\ref{sec-learn}).
Coupled with rules generated by learner module,
we will have a complete language model to verify configuration files
of our interest.

Translating or parsing is system dependent. In other words, for MySQL
and HDFS, we need to develop different parsers to handle each of them,
respectively. \app allows users to 
provide an extra help to the translator
for their specific system configurations,
but it is not required.

The majority of entries in a configuration files are assignments.Our first attempt was to simply
translate every key-value entry {\tt {k = v}} into a triple $(k, v, \tau)$, where $\tau$ is a type of 
$v$. However, sometimes we could not fully determine the type of key 
based on a single example value. For this reason, we introduced {\emph {probabilistic types}}.

Consider the following example.

\noindent{\tt {foo = 300}}\\
{\tt {bar = 300.txt}}

Most likely {\tt foo} should be an integer, but it could also be a string.
In the second case, we can learn the rule stating 
$ \texttt{foo} \in \textsf{substrings}(\texttt{bar})$. 
Instead of assigning one type to a value, the translator assigns a distribution of types 
to a value, an idea closely related to existentially quantified 
types~\cite{Launchbury93lazyfunctional}. 

Formally, we define probabilistic types as follows: let $\mathcal{T}$ be a set of basic types (cf. Table~\ref{table:kysymys}).
A probabilistic type built from $\mathcal{T}$ is a list of pairs 
$[(\tau_1, p_1),\ldots,(\tau_n, p_n)]$,
such that $\tau_i \in \mathcal{T}$, $0 \le p_i \le 1$ 
and $\Sigma p_i = 1$. 
These probabilities are updated each time a new example value 
for a key is encountered.

When a value has a probabilistic type, we generate rules for all its types.
This means that by assigning {\texttt{foo}} a probabilistic type 
(\eg, {\tt (\texttt{foo}, 300, [(\textsl{Int},90\%), 
(\textsl{String},10\%)])},
we would generate rules for both strings and integers.
Once the type inference can uniquely determine the type, 
the probability of all other types is set to zero, 
and the associated rules are withdrawn.

In \app set $\mathcal{T}$ contains strings, integers, file paths, 
sizes and IP addresses. With every type we associate a list of templates 
that are use to learn the rules about that files. Table~\ref{table:kysymys} contains
the most important types and templates.

\begin{table}
  \begin{tabular}{| l |  l |}
    \hline
    Type & Operation  \\ \hline
    Integer & $X = Y, X\neq Y, X \leq Y, X < Y, X * Y < Z, \ldots $\\ \hline
    String & $U = V, U \neq V, \textsf{prefix}(U,V), \textsf{sufix}(U,V), \ldots$   \\ \hline
    File & $\textsf{file}(F), \textsf{dir}(D),\ldots$   \\ \hline
    Size & similar as for integers   \\ \hline
    Port &    \\ \hline
    IP Addr.  &   \\
    
    \hline
  \end{tabular}
\caption{Table of types used in \app together with templates associated to every type}
\label{table:kysymys}
\end{table}







\para{Formal Intermediate Representation.}

An additional problem is that configuration files sometimes contain a simple version of the {\tt {if-then}} which 
sets under which conditions some actions should be applied. 




The formal grammar we use for our intermediate representation presented in the following. 
Firstly, we make a list of the possible types for a configuration file. This is present in 
Secondly, we 


We come up with the following types:

1. Port 
The $i$-th entry inside an intermediate representation corresponding to a 
translated file 

We declare a quadruple $(g,k,v,\{\tau_1, \ldots, \tau_n\}_i$
We need a kind of formal definition (using a figure) to
define the grammar of our intermediate representation. The basic
view of this definition should be similar to define a type language
grammar.


\com{Note that typing is also a system module than 
can be easily extended to support more types. 
In that case the user will need to provide rules for type inference 
and probability distributions for values where type inference is ambiguous.
}
