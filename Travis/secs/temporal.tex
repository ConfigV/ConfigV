\section{Learning from Temporal properties}

%The first step is to build an intermediate representation of the data we will learn.
%This data must be structured as a shallow tree for generalizable learning.
%This restriction is why this approach is not appropriate for language learning on large grammars (such as a programming language).

ConfigC can provide justifications, but has a high false positive rate.
However, ConfigC only analyzes correct configuration files, and does not consider any ordering between these correct files.
We present a new algorithm to decrease the false positive rate in ConfigC by learning on both correct and incorrect examples, as well as temporal structure of these examples.
This extension will build a logical formula representing the entire history of examples, and use a SMT solver to find a classification model.

Since a TravisCI configuration file is dependent on the code it is trying to build, we must consider a more general sense of configuration file.
We will call this a program summary $P_t$, which is a representation of the repository which contains the information relevant to the learning process.
The subscript on $P_t$ is a timestamp tag based on the ordered git commit history.
In the case of TravisCI, this include the \verb|.travis.yml| file, as well as code features that may effect build status, such as programming language and a list of imported libraries.
The summary must be \textit{sufficiently detailed}, that is it must contain every piece of information that might lead to a build error.

%IMPORTANT, but no space
However, a git history is not a limited to a single linear timeline.
Git features the ability to \textit{branch}, which allows to simultaneous commit chains.
To handle the start of a branch, add a superscript to indicate the branch, and restart the counter on a branch.
To handle the merge of two branches $P_{t}^{x}$ and $P_{t'}^{y}$, step to $P_{t+1}^{x}$, where $x$ is the mainline branch.
We then say that $P_{t'}^{y}$ has no successor commit $P_{t'+1}^{y}$.
Note the ability to handle branching implies this method is suitable to any learning set which has a partial order.

From this summary we can then build a model $M(P_t)$, as in ConfigC, which is the full set of possible relations derivable from the program summary.
Again, the user must provide templates for the learning process.

We will denote the build status returned from TravisCI when run on $P_t$ with $S(P_t)$.
Any files with a $Pass$ build status are correct, and any files with an $Err$ build status are incorrect.
In this application, we consider all non-erroring build status to be passing, denoted $Pass$ and otherwise $Err$.
For brevity, we denote sequences of build statuses with the following notation:
\begin{align*}
  S(P_t)=Pass \land S(P_{t+1})=Err \implies S(P_{t,t+1}) = PE
\end{align*}

In contrast with ConfigC, we now consider both incorrect and correct and so must introduce the \textit{general boundary}.
The general boundary is the dual of the specific boundary, and is the most relaxed requirement for a positive classification.
We denoted specific boundary as the set of necessary relations $Nec$, and now denote the general boundary as the set of breaking relations $Br$.
With this notation, we can formally express the requirement that the program summary is sufficiently detailed.
\begin{align}
  \forall S(P_t)=Err, \exists r \in M(P_t), r \in Br \label{eq:E1}
\end{align}

From the above we know that if a build is erroring, then there must exist at least one error.
%By pushing the negation into the formula,
We can also know that if a build is passing, then there must not exist any errors.
That is, the model of a passing commit must not contain any rules which are breaking.
Note we are not, however, guaranteed that any rules from a passing commit are necessary.
\begin{align}
  S(P_t) = Err \implies \exists r \in  M (P_t), r \in Br \label{eq:E}\\
  S(P_t) = Pass \implies \forall r \in  M (P_t), r \notin Br \label{eq:P}
\end{align}

%While Eq. \ref{eq:E} and \ref{eq:P} might build a basic model, they will do not capture all of the available knowledge.
%The key insight is that 
Additionally, when we commit a break ($PE$), we can localize the error to one of the relations that changed.
Either we removed something that was necessary, or added something that was breaking.
Note that this is an inclusive disjunction, since a erroring commit can break multiple things at once.
Expressed formally, where $\setminus$ is the set difference, that is:
\begin{align}
  S(P_{t,t+1}) &= PE \implies \nonumber \\
  \exists& r \in (M(P_{t})\ \setminus M(P_{t+1})), r \in Nec\ \nonumber \\
  \lor \ \exists& r \in (M(P_{t+1}) \setminus M(P_{t})), r \in Br \label{eq:PE}
\end{align}

We then can combine Eq \ref{eq:E}, \ref{eq:P}, and \ref{eq:PE} with conjunctions and ask a SMT solver for a model satifying the formula.
The resulting model will be the sets $Nec$, and $Br$, which can be used to check new configuration files.
Since we used a similar model to ConfigC, we will still be able to provide justifications for the classification results.

While existential set operations can be expensive on large sets for an SMT solver, in our application this is not the case.
Thanks to the practice of making incremental commits when using source control, these sets will be small and the SMT will be fairly cheap.
In fact, the above implication generalizes to $P_{t,t+n}$, but for efficiency we must require that $M(P_{t})\ \setminus M(P_{t+n})$ is manageably small.
The definition of small here remains to be experimentally determined.
