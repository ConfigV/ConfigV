\section{Learning from Temporal properties}

An interesting extension to ConfigC on a theoretical side is to look at the temporal relations between commits.
The key observation is that with each commit that changes the build status, we can learn highly localized information about our model.

The first step is to build an intermediate representation of the data we will learn.
This data must be structured as a shallow tree for generalizable learning.
This restriction is why this approach is not appropriate for language learning on large grammars (such as a programming language).


While the travis.yml file has a simple structure and can be taken verbatim, we must use a simplification of the program code.
Since we are only interested in the parts of the program effecting build status, we should extract key feautres such as programming language and a list of imported libraries.
We will call this program summary $P_t$, a simplified representation of the repository which contains only the information relevant to the learning process.
The summary must contains every piece of information that might lead to a build error.

The subscript on $P_t$ is a tag based on the ordered commit history.
However, a git history is not a limited to a single linear timeline.
Git features the ability to \textit{branch}, which allows to simultanious commit chains.
To handle the start of a branch, add a superscript to indicate the branch, and restart the counter on a branch.
To handle the merge of two branches $P_{t}^{x}$ and $P_{t'}^{y}$, step to $P_{t+1}^{x}$, where $x$ is the mainline branch.
We then say that $P_{t'}^{y}$ has no successor commit $P_{t'+1}^{y}$.

From this summary we can then build a model $M(P_t)$, which is the full set of possible rules derivable from the program summary.
These possible rules must be given by the user.
In \cite{Santolucito2016}, these were called Attributes, and express constraints such as, ordering of lines, or substring relations on values.

We will denote the build status of $P_t$ with $B(P_t)$.
In this application, we consider only the passing and erroring build status, denoted $Pass$, and $Err$ respectively.
All status that are not \verb|error|, as defined by the Travis API, will be included as passing.
For brevity, we denote sequences of build statuses with the following notation:

\begin{align*}
  S(P_t)=Pass \land S(P_{t+1})=Err \implies S(P_{t,t+1}) = PE
\end{align*}

With this notation, we can formally express the requirement that the program summary is complete.
This is an assumption on the quality of the program summary.

\begin{align*}
  \forall S(P_t)=Err, \exists r \in M(P_t), r \in Br
\end{align*}

From the above we know that if a build is erroring, then there must exist at least one error.
By pushing the negation into the formula, we can also know that if a build is passing, then there must not exist any errors. 
That is, the model of a passing commit must not contain any rules which are breaking. 
Note we are not, however, garunteed that any rules from a passing commit are necessary.


\begin{align}
  S(P_t) = Err \implies \exists r \in  M (P_t), r \in Br \label{eq:E}\\
  S(P_t) = Pass \implies \forall r \in  M (P_t), r \notin Br \label{eq:P}
\end{align}

While Eq. \ref{eq:E} and \ref{eq:P} might build a basic model, they will do not capture all of the available knowledge.
The key insight is that when we commit a break (P E), we can localize the error to one of the lines that changed.
Either we removed something that was necessary, or added something that was breaking. 
We use an inclusive disjunction, since a erroring commit can break multiple things at once. 
Expressed formally, where (\ is the set difference), that is:


\begin{align}
  S(P_{t,t+1}) = PE \implies \nonumber \\
  \exists r \in (M(P_{t})\ \setminus M(P_{t+1})), r \in Nec\ \lor \nonumber \\
  \exists r \in (M(P_{t+1}) \setminus M(P_{t})), r \in Br \label{eq:PE}
\end{align}

We then can combine all these formulas with conjunctions and send it to an SMT solver.
While existential set operations can be expensive on large sets for an SMT solver, in our application this is not the case.
Thanks to the practice of making incremental commits when using source control, these sets will be small and the SMT will be fairly cheap. 
In fact, the above implication generalizes to $P_{t,t+n}$, but for efficiency we must require that $M(P_{t})\ \setminus M(P_{t+n})$ is manageably small. 
The definition of small here remains to be experimentally determined.

\subsection{Unsatisfiability}
Note we have made a strong assumption that the summary $P_t$ contains every piece of information that might lead to a build error. 
This is the strongest assumption that we make - however our algorithm is able to detect cases where the summary is incomplete.
If we cannot find a solution for Eq. 3 it means that the set of rules we are looking for is incomplete.
