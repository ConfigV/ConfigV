
To overcome these obstacles, researchers proposed approaches based on
statistical analysis and learning%
~\cite{wang04automatic, zhang14encore, yuan11context}
that try to infer rules and policies about 
how configuration files are constructed.
Rather than explicitly specifying entries' types or rules, 
these efforts focused on learning policies from a sample dataset.
The learned rules are usually constructed in the following way: 
for every entry in a configuration file, 
they check if it deviates from a ``typical'' value, \ie, 
a value computed from a large training set 
consisting of configuration files.
If the entry is significantly different from a typical value, 
they suspect that it could be a potential configuration error.

The downside of these is that their learning approaches 
are limited to simplistic configuration errors, 
such as type errors and syntax errors, or they 
heavily rely on template-based inference~\cite{zhang14encore}. 

Many sophisticated configuration errors, 
which are difficult to template in practice, 
cannot be detected in this way. 
As an illustration of such an error, consider entry ordering errors, 
which happens when some entries are inserted in a wrong order. 
For example, if in a PHP configuration file 
an entry {\tt extension = mysql.so} appears 
before {\tt extension = recode.so},  
it would lead to a crash error, where the Apache server cannot start 
due to the segmentation fault error. The correct ordering 
should be {\tt extension = recode.so} before 
{\tt extension = mysql.so}~\cite{yin11anempirical}.
These types of errors cannot be detected by existing
learning efforts, 
since it is hard to build a corresponding template~\cite{xu15systems}. 
%we would need to capture ordering relations of all the entries. 
%Some of them can appear in an arbitrary ordering, 
%and the resulting templates would be too large 
%and not efficient for a practical use.

%Offering automatic verification to configuration files -- like
%what we did to programs -- has been advocated as a reasonable means
%to check the correctness of configuration files of interest.
%Nevertheless, it is still an open problem, because 
%1) software configurations are typically written in poorly structured 
%and untyped languages, and 2) writing specifications or constraints
%for configuration verification is non-trivial in practice.

