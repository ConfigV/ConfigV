
\section{Extending \app and Applying it to Real-World Configurations}
\label{sec:travis}

TravisCI~\cite{API} is a popular integration and build testing service 
connected to Github. It has been used on more than 17 
millions of projects. 
TravisCI allows programmers to automatically run their test suite on a fresh virtual machine every time they commit their code.
A TravisCI user must add a configuration file to the repository that specifies build conditions, 
such as which dependencies are required, and a set of benchmarks to test. 
The results of these tests (indicating either passing, failing, or misconfiguration) 
are saved by TravisCI on a publicly available database~\cite{API}.

TravisCI misconfigurations are important to detect and correct 
because of any failed compilation can costs developer significant amount 
of time. A misconfiguration can cause a test suite to run up to 20 
minutes, only to report a misconfiguration~\cite{API}.
The developer will need to wait to get such a report back to begin even identifying the error.

A new challenge here is that we need to reason about a 
temporal component too. Having an entire TravisCI log for a given
project we can examine the sequence of changes of a configuration file
and we can detect what has changed so that we switched from a failing 
compilation to successful compilation. 

%Driven by the above motivating example, we propose an extension to \app that
%learns over a training set with both correct and incorrect examples, as well as a temporal structure.
%Such an extension employs an existing technique from the machine learning community, called version space learning,
%to significantly decrease the false positive rate while maintaining the detection capability of \app.

\subsection{Version Space Learning with Temporal Properties} 

Version space learning builds a logical constraint model for binary
classification~\cite{mitchell77}, which we use to test a configuration file for membership
in the set of all correct files.
Traditionally, version space learning builds a model that defines membership using a series of disjunctions from a set of predefined hypotheses. However, we need  to use conjunctions to convey that a configuration file is only correct if it satisfies all the learned relations, as


\begin{figure}[!tbh]
  \centering
  \begin{tikzpicture}
    \draw (2,0) rectangle (6,2); \draw (2.5,0.5) rectangle (5.5,1.5);
  \end{tikzpicture}
  \caption{System architecture of }
  \label{fig:screenshot1}
\end{figure}

 Adding this temporal component, 
This extension will build a logical formula representing the entire 
history of examples, and use an SMT solver to find a classification model.

Since a TravisCI configuration file is dependent
on the code and system it is trying to build, 
we must consider a more general sense of configuration file.
We will call this a program summary $P_t$, which is a representation 
of the repository which contains the information 
relevant to the learning process.
The subscript on $P_t$ is a timestamp tag based on 
the ordered git commit history.
%In the case of TravisCI, this include the \verb|.travis.yml| file, 
%as well as code features that may effect build status, 
%such as programming language and a list of imported libraries.
%The summary must be \textit{sufficiently detailed}, that is it must contain every piece of information that might lead to a build error.

%IMPORTANT, but no space
%However, a git history is not a limited to a single linear timeline.
%Git features the ability to \textit{branch}, which allows to simultaneous commit chains.
%To handle the start of a branch, add a superscript to indicate the branch, and restart the counter on a branch.
%To handle the merge of two branches $P_{t}^{x}$ and $P_{t'}^{y}$, step to $P_{t+1}^{x}$, where $x$ is the mainline branch.
%We then say that $P_{t'}^{y}$ has no successor commit $P_{t'+1}^{y}$.

From this summary we can then build a model $M(P_t)$, as in \app,
which is the full set of possible relations derivable 
from the program summary.
Again, the user must provide templates for the learning process.

We will denote the build status returned from TravisCI when run on $P_t$ with $S(P_t)$.
Any files with a $Pass$ build status are correct, and any files with an $Err$ build status are incorrect.
%In this application, we consider all non-erroring build status to be passing, denoted $Pass$ and otherwise $Err$.
For brevity, we denote sequences of build statuses with the following notation:
\begin{align*}
  S(P_t)=Pass \land S(P_{t+1})=Err \implies S(P_{t,t+1}) = PE
\end{align*}

We now consider both incorrect and correct files in the training set 
and so must introduce the \textit{general boundary}.
The general boundary is the dual of the specific boundary, and is the most relaxed requirement for a positive classification.
We denoted specific boundary as the set of necessary relations $Nec$, and now denote the general boundary as the set of breaking relations $Br$.
With this notation, we can formally express the requirement that the program summary is sufficiently detailed.
\begin{align}
  \forall S(P_t)=Err, \exists r \in M(P_t), r \in Br \label{eq:E1}
\end{align}

From the above we know that if a build is erroring, then there must exist at least one error.
We can also know that if a build is passing, then there must not exist any errors.
That is, the model of a passing commit must not contain any rules which are breaking.
Note we are not, however, guaranteed that any rules from a passing commit are necessary.
\begin{align}
  S(P_t) = Err \implies \exists r \in  M (P_t), r \in Br \label{eq:E}\\
  S(P_t) = Pass \implies \forall r \in  M (P_t), r \notin Br \label{eq:P}
\end{align}

%While Eq. \ref{eq:E} and \ref{eq:P} might build a basic model, they will do not capture all of the available knowledge.
%The key insight is that 
Additionally, when we commit a break ($PE$), we can localize the error to one of the relations that changed.
Either we removed something that was necessary, or added something that was breaking.
Note that this is an inclusive disjunction, since a erroring commit can break multiple things at once.
Expressed formally, where $\setminus$ is the set difference, that is:
\begin{align}
  S(P_{t,t+1}) &= PE \implies \nonumber \\
  \exists& r \in (M(P_{t})\ \setminus M(P_{t+1})), r \in Nec\ \nonumber \\
  \lor \ \exists& r \in (M(P_{t+1}) \setminus M(P_{t})), r \in Br \label{eq:PE}
\end{align}

We then can combine Eq \ref{eq:E}, \ref{eq:P}, and \ref{eq:PE} with
conjunctions and ask a SMT solver for a model satisfying the formula.
The resulting model will be the sets of necessary rules ($Nec$), and the set of breaking rules ($Br$), which can be used to check new configuration files.
Since we used a similar model to \app, we will still be able to provide justifications for the classification results.

