\section{Our Previous Work: ConfigC}
\label{sec:prelim}

Based on our own experience with misconfigurations,
we have proposed and developed a simple tool for verification of 
configuration files, named
ConfigC~\cite{santolucitoCAV}. Motivated by promising preliminary
results, which we obtained with ConfigC, we believe that automated 
verification of configuration files is possible and that it should be further studied.

From ConfigC we drew the main inspiration for this proposal. We now briefly
outline how does ConfigC work. It first automatically
analyzes a dataset of correct configuration files to derive
 rules for describing a specification. Before that process even starts,
we identified several basic types, 
such Boolean, Integer, File. With each of these types we associated a 
list of templates. We then analyze the given training data set of 
correct configuration files and derive rules describing variable                                                                                                                                                                                                                                                                                                                                                                                                                       
relations. We illustrate how is this done on two fragments of 
configuration files given in Fig.~\ref{fig:twoFiles}.  When analyzing
a file, we first assign a type to every 
keyword. After that we instantiate each type-annotated template with 
concrete keywords and we save the learned set 
of rules. For instance, with the integer type we only associated comparison templates ($X < Y, X = Y, \ldots$). After 
analyzing File\_1, the set of learned rules will contain the following rules:
\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
max_connections=300
mysql.max_persistent=200
max_connections > mysql.max_persistent
\end{lstlisting}
The set of learned rules is changing with every file that we analyze: contradicting 
files are removed and new rules are added. After analyzing File\_2 the rule \texttt{max\_connections = 300} is removed. In practice, this process is done 
in parallel. 


\begin{figure}
	\centering
\begin{minipage}{0.9\textwidth}
\begin{parcolumns}{2}
\colchunk{\begin{lstlisting}[language=C, frame=tb, xleftmargin=.01\textwidth]
File_1:
max_connections=300
general_log=1
...
mysql.max_persistent=200
\end{lstlisting}}

\colchunk{\begin{lstlisting}[language=C, frame=tb, xleftmargin=.01\textwidth]
File_2:
max_connections=400
general_log=0
...
mysql.max_persistent=200
\end{lstlisting}}

\colplacechunks
\end{parcolumns}
\end{minipage}
	\caption{Fragments of two configuration files for configuring PHP on MySQL}
	\label{fig:twoFiles}
\end{figure}


Additionally to the described process, we also developed algorithms for 
the misconfigurations that cannot easily be templated. All together, 
ConfigC can detect the following errors:
missing entries, ordering errors, type errors and
simple value correlations. Once this preprocessing of training data is 
done, the resulting language model, 
together with accompanying rules, 
is used to detect errors in new configuration files given by the user.

Running ConfigC on Example~1 from 
Sec.~\ref{sec:intro-examples} returns the following output:
\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
ORDERING ERROR: Expected extension "recode.so" BEFORE 
extension "mysql.so"
\end{lstlisting} 
ConfigC could not detect an error present in Example~2 since it can detect 
only simple comparison-based relations.

\iffalse

ConfigC can detect the above errors by overcoming 
main technical challenges against automatic configuration verification.
First, because writing specifications for configuration verification
is difficult -- especially for specifying the above
tricky configuration errors, \eg, missing entry and ordering errors,
ConfigC employs a set of machine learning algorithms to
automate the specification writing. Machine learning based approach
employed by ConfigC enables the process of specification writing to become
automatic. As long as a set of configuration files are provided,
ConfigC can automatically generate a set of rules that could be used
as specifications.
Second, because existing configuration files do not have any language
structures and grammar, it is difficult to verify configuration files.
ConfigC proposes a new language model and transforms target configuration
files into the proposed language model. In other words, ConfigC uses
the language model as a uniform representation and parses the 
configuration files to verify into such a representation.
With the uniform representation and specifications in hand,
ConfigC is able to verify whether the given configuration files
meet the specification.

\fi 


\begin{table}[h]
\centering
\caption{Evaluation results on misconfiguration detection of ConfigC}
\label{table:res}
\begin{tabular}{|l|l|l|}
\hline
Error Type       & Passing Tests & False Positives  \\ 
\hline
\hline
Missing Entry      & 5/5           & 1, 0, 0, 0, 4        \\ \hline
Type Error         & 5/5           & 0, 0, 0, 0, 0          \\ \hline
Ordering Error     & 5/5           & 0, 2, 1, 0, 6       \\ \hline
Value Correlation  & 4/5           & 0, 0, 0, 1, 0        \\ 
\hline
\end{tabular}
\end{table}

We implemented a prototype and evaluated it on 
real-world MySQL configuration files~\cite{configdataset}.
We manually extracted 20 files that contained errors which our tool 
can detect and grouped them into four categories according to their
error types: missing entry, type error, ordering error
and value correlation. The evaluation results are shown in 
Table~\ref{table:res}. We can see that the our tool can detect most of 
the errors, with a low number of false positives. We believe that further
studies in this direction will bring us better results

\subsection{Limitations of ConfigC}
Despite promising early results, ConfigC was a first experimental attempt 
into formal verification of configuration files, and as such it still has several limitations.

\begin{enumerate}

\item ConfigC works on the premise that the training dataset consists 
only of correct files, which is hard to achieve in practice. In the 
prototype we manually checked every file in the prototype. Clearly, this 
approach will not scale in practice. There exist a large set of 
real-world misconfigurations~\cite{configdataset}. Nevertheless, the 
errors are distributed through the files and do not all appear at the 
same spot. We believe that it should be possible to construct a correct
specification from the rules that hold in a significant majority of the 
files.

\item A language model used in ConfigC cannot handle a simple version of 
the {\tt {if-then}} command that sometimes appears in some configuration
files (such as Apache HTTPD). We already pointed out some issues with 
parsing and possible wrong typing. We need to develop a more 
accurate model which will be a uniform representation for diverse
  configuration files.

\item ConfigC offers only a limited number of templates to to detect 
correlation errors on keywords. It can detect, for example, 
keyword comparisons, but in practice many software outages were 
caused by more complex correlations (also called
  fine-grained correlations~\cite{correlation}). As an illustration,
  ConfigC cannot find an error in Example~2 in 
Sec.~\ref{sec:intro-examples}. However, to detect more complex rules, we will need to use tools like SMT solvers \cite{z3, cvc4}.


\item ConfigC cannot check for anomalies in a value set for one particular keyword. For example,
  setting a parameter, which relates memory in MySQL configuration 
  files, too large can cause exhausting the RAM and causing extreme 
  slowness or even a crash. Such an anomalous value does not violate any
  previously mentioned constraints (such as type errors or ordering errors), but yet 
  it makes system behave wrongly.

\end{enumerate}

This proposal aims to address all the above limitations. 
