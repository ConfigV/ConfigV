\section{Our Previous Work: ConfigC}
\label{sec:prelim}

Based on our own experience with misconfigurations,
we have proposed and developed a simple tool for verification of 
configuration files, named
ConfigC~\cite{santolucitoCAV}. Motivated by promising preliminary
results, which we obtained with ConfigC, we believe that automated 
verification of configuration files is possible and that it should be further studied.

From ConfigC we drew the main inspiration for this proposal. We now briefly
outline how does ConfigC work. It first automatically
analyzes a dataset of correct configuration files to derive
 rules for describing a specification. Before that process even starts,
we identified several basic types, 
such Boolean, Integer, File. With each of these files we associated a 
list of templates. We then analyze the given training data set of 
correct configuration files and derive rules describing variable 
relations. We demonstrate how it works on two fragments of configuration 
files given in Fig.~\ref{fig:twoFiles}.  When analyzing
a file, we first do type-checking, \ie we assign a type to every variable. After that we instantiate each template with the typed variables and we save the learned set 
of rules. For instance, with the integer type we only associated comparison templates ($X < Y, X = Y, \ldots$). After 
analyzing File\_1, the set of learned rules will contain the following rules:
\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
max_connections=300
mysql.max_persistent=200
max_connections > mysql.max_persistent
\end{lstlisting}
The set of learned rules is changing with every file that we analyze: contradicting 
files are removed and new rules are added. In practice, this process is done 
in parallel. 

After analyzing File$_2$ the rule \texttt{max\_connections = 300} is removed. 

\begin{figure}
	\centering
\begin{minipage}{0.9\textwidth}
\begin{parcolumns}{2}
\colchunk{\begin{lstlisting}[language=C, frame=tb, xleftmargin=.01\textwidth]
File_1:
max_connections=300
general_log=1
...
mysql.max_persistent=200
\end{lstlisting}}

\colchunk{\begin{lstlisting}[language=C, frame=tb, xleftmargin=.01\textwidth]
File_2:
max_connections=400
general_log=0
...
mysql.max_persistent=200
\end{lstlisting}}

\colplacechunks
\end{parcolumns}
\end{minipage}
	\caption{Fragments of two configuration files for configuring PHP on MySQL}
	\label{fig:twoFiles}
\end{figure}


Once this preprocessing of training data is done, the resulting language model, 
together with accompanying rules, 
is used to detect errors in new configuration files given by the user.

Additional to the described process we also developed algorithms for the 
misconfigurations that cannot easily be templated. All together, ConfigC 
can detect the following errors:
missing entries, ordering errors, type errors and
simple value correlations. Running ConfigC on Example~1 from 
Sec.~\ref{sec:intro-examples} returns the following output:
\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
ORDERING ERROR: Expected extension "recode.so" BEFORE 
extension "mysql.so"
\end{lstlisting} 
ConfigC could not detect an error present in Example~2 since it can detect 
only simple comparison-based relations.


To our knowledge, there is no existing effort that is able to detect
the above errors, because they are very tricky to identify in
practice.

ConfigC can detect the above errors by overcoming 
main technical challenges against automatic configuration verification.
First, because writing specifications for configuration verification
is difficult -- especially for specifying the above
tricky configuration errors, \eg, missing entry and ordering errors,
ConfigC employs a set of machine learning algorithms to
automate the specification writing. Machine learning based approach
employed by ConfigC enables the process of specification writing to become
automatic. As long as a set of configuration files are provided,
ConfigC can automatically generate a set of rules that could be used
as specifications.
Second, because existing configuration files do not have any language
structures and grammar, it is difficult to verify configuration files.
ConfigC proposes a new language model and transforms target configuration
files into the proposed language model. In other words, ConfigC uses
the language model as a uniform representation and parses the 
configuration files to verify into such a representation.
With the uniform representation and specifications in hand,
ConfigC is able to verify whether the given configuration files
meet the specification.

\paragraph{Evaluations on ConfigC.}
We implemented a prototype system by following 
our ConfigC design~\cite{santolucitoCAV}.
In order to demonstrate the capability of ConfigC,
we evaluated the ConfigC prototype based on real-world
MySQL configuration files~\cite{configdataset} 
containing tricky misconfiguration errors,
such as entry missing errors, ordering errors, and
value correlation errors.
We extracted 20 MySQL configuration files to detect, 
and grouped them into four categories according to their
error types: missing entry, type error, ordering error
and value correlation.
Table~\ref{table:res} shows the evaluation results we use
ConfigC to detect configuration errors in these 20 real-world
configuration files.
As shown in Table~\ref{table:res},
ConfigC is able to successfully report the misconfiguration problems.

\begin{table}[h]
\centering
\caption{Evaluation results on misconfiguration detection of ConfigC}
\label{table:res}
\begin{tabular}{|l|l|l|}
\hline
Error Type       & Passing Tests & False Positives  \\ 
\hline
\hline
Missing Entry      & 5/5           & 1, 0, 0, 0, 4        \\ \hline
Type Error         & 5/5           & 0, 0, 0, 0, 0          \\ \hline
Ordering Error     & 5/5           & 0, 2, 1, 0, 6       \\ \hline
Value Correlation  & 4/5           & 0, 0, 0, 1, 0        \\ 
\hline
\end{tabular}
\end{table}

\paragraph{Limitations.}
ConfigC still has the following limitations.

\begin{enumerate}

\item ConfigC requires the datasets of configuration files for training 
  have to be correct, which is hard to achieve in practice, since 
  it is difficult for administrators or users to offer a
  set of 100\% correct configuration files for training.

\item The language model of ConfigC is still a starting point. It
  is hard to formulate a uniform representation for diverse
  configuration files.\ennan{we still need to put one more sentence
  here to distinguish why our current language model is better
  than ConfigC's language model}

\item ConfigC can only offer coarse-grained value correlation errors,
  \eg, $\texttt{max\_connections} > \texttt{mysql.max\_persistent}$.
  In practice, many software outages were caused by more tricky, called
  fine-grained value correlation~\cite{correlation}. For example, 
  in a MySQL configuration file, $\texttt{key\_buffer\_size}$ should be 
  higher than $\texttt{max\_connections} \times 
  \texttt{sort\_buffer\_size}$~\cite{correlation};
  otherwise, the MySQL load will be very high.

\item ConfigC cannot check singular value anomalies. For example,
  a parameter relating to memory in MySQL configuration files is
  setted too large, exhausting the RAM and causing extreme slowness
  or even a crash. Such an anomalous value does not violate any
  constraints (\eg, type error and value ordering error), but 
  it makes system behave wrongly.

\end{enumerate}

This proposal aims to address the above limitations. 
