\section{Our Previous Work: ConfigC}
\label{sec:prelim}

Based on our own experience with misconfigurations,
we have proposed and developed a simple tool for verification of 
configuration files, named
ConfigC~\cite{santolucitoCAV}. Motivated by promising preliminary
results, which we obtained with ConfigC, we believe that automated 
verification of configuration files is possible and that it should be further studied.

From ConfigC we drew the main inspiration for this proposal. We now briefly
outline how does ConfigC work. It first automatically
analyzes a dataset of correct configuration files to derive
 rules for describing a specification. Before that process even starts,
we identified several basic types, 
such Boolean, Integer, File. With each of these types we associated a 
list of templates. We then analyze the given training data set of 
correct configuration files and derive rules describing variable                                                                                                                                                                                                                                                                                                                                                                                                                       
relations. We illustrate how is this done on two fragments of 
configuration files given in Fig.~\ref{fig:twoFiles}.  When analyzing
a file, we first assign a type to every 
keyword. After that we instantiate each type-annotated template with 
concrete keywords and we save the learned set 
of rules. For instance, with the integer type we only associated comparison templates ($X < Y, X = Y, \ldots$). After 
analyzing File\_1, the set of learned rules will contain the following rules:
\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
max_connections=300
mysql.max_persistent=200
max_connections > mysql.max_persistent
\end{lstlisting}
The set of learned rules is changing with every file that we analyze: contradicting 
files are removed and new rules are added. After analyzing File\_2 the rule \texttt{max\_connections = 300} is removed. In practice, this process is done 
in parallel. 


\begin{figure}
	\centering
\begin{minipage}{0.9\textwidth}
\begin{parcolumns}{2}
\colchunk{\begin{lstlisting}[language=C, frame=tb, xleftmargin=.01\textwidth]
File_1:
max_connections=300
general_log=1
...
mysql.max_persistent=200
\end{lstlisting}}

\colchunk{\begin{lstlisting}[language=C, frame=tb, xleftmargin=.01\textwidth]
File_2:
max_connections=400
general_log=0
...
mysql.max_persistent=200
\end{lstlisting}}

\colplacechunks
\end{parcolumns}
\end{minipage}
	\caption{Fragments of two configuration files for configuring PHP on MySQL}
	\label{fig:twoFiles}
\end{figure}


Additionally to the described process, we also developed algorithms for 
the misconfigurations that cannot easily be templated. All together, 
ConfigC can detect the following errors:
missing entries, ordering errors, type errors and
simple value correlations. Once this preprocessing of training data is 
done, the resulting language model, 
together with accompanying rules, 
is used to detect errors in new configuration files given by the user.

Running ConfigC on Example~1 from 
Sec.~\ref{sec:intro-examples} returns the following output:
\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
ORDERING ERROR: Expected extension "recode.so" BEFORE 
extension "mysql.so"
\end{lstlisting} 
ConfigC could not detect an error present in Example~2 since it can detect 
only simple comparison-based relations.

\iffalse

ConfigC can detect the above errors by overcoming 
main technical challenges against automatic configuration verification.
First, because writing specifications for configuration verification
is difficult -- especially for specifying the above
tricky configuration errors, \eg, missing entry and ordering errors,
ConfigC employs a set of machine learning algorithms to
automate the specification writing. Machine learning based approach
employed by ConfigC enables the process of specification writing to become
automatic. As long as a set of configuration files are provided,
ConfigC can automatically generate a set of rules that could be used
as specifications.
Second, because existing configuration files do not have any language
structures and grammar, it is difficult to verify configuration files.
ConfigC proposes a new language model and transforms target configuration
files into the proposed language model. In other words, ConfigC uses
the language model as a uniform representation and parses the 
configuration files to verify into such a representation.
With the uniform representation and specifications in hand,
ConfigC is able to verify whether the given configuration files
meet the specification.

\fi 


\begin{table}[h]
\centering
\caption{Evaluation results on misconfiguration detection of ConfigC}
\label{table:res}
\begin{tabular}{|l|l|l|}
\hline
Error Type       & Passing Tests & False Positives  \\ 
\hline
\hline
Missing Entry      & 5/5           & 1, 0, 0, 0, 4        \\ \hline
Type Error         & 5/5           & 0, 0, 0, 0, 0          \\ \hline
Ordering Error     & 5/5           & 0, 2, 1, 0, 6       \\ \hline
Value Correlation  & 4/5           & 0, 0, 0, 1, 0        \\ 
\hline
\end{tabular}
\end{table}

We implemented a prototype and evaluated it on 
real-world MySQL configuration files~\cite{configdataset}.
We manually extracted 20 files that contained errors which our tool 
can detect and grouped them into four categories according to their
error types: missing entry, type error, ordering error
and value correlation. The evaluation results are shown in 
Table~\ref{table:res}. We can see that the our tool can detect most of 
the errors, with a low number of false positives. We believe that further
studies in this direction will bring us better results

\subsection{Limitations of ConfigC}
Despite promising early results, ConfigC was a first experimental attempt 
into formal verification of configuration files, and as such it still has several limitations.

\begin{enumerate}

\item ConfigC works on the premise that training dataset consists only 
of correct files, which is hard to achieve in practice. In the 
prototype we manually checked every file in the prototype. Clearly, this approach will not scale and  since 
  it is difficult for administrators or users to offer a
  set of 100\% correct configuration files for training.

\item The language model of ConfigC is still a starting point. It
  is hard to formulate a uniform representation for diverse
  configuration files.\ennan{we still need to put one more sentence
  here to distinguish why our current language model is better
  than ConfigC's language model}

\item ConfigC can only offer coarse-grained value correlation errors,
  \eg, $\texttt{max\_connections} > \texttt{mysql.max\_persistent}$.
  In practice, many software outages were caused by more tricky, called
  fine-grained value correlation~\cite{correlation}. For example, 
  in a MySQL configuration file, $\texttt{key\_buffer\_size}$ should be 
  higher than $\texttt{max\_connections} \times 
  \texttt{sort\_buffer\_size}$~\cite{correlation};
  otherwise, the MySQL load will be very high.

\item ConfigC cannot check singular value anomalies. For example,
  a parameter relating to memory in MySQL configuration files is
  setted too large, exhausting the RAM and causing extreme slowness
  or even a crash. Such an anomalous value does not violate any
  constraints (\eg, type error and value ordering error), but 
  it makes system behave wrongly.

\end{enumerate}

This proposal aims to address the above limitations. 
