\subsection{A Language Model for Configuration Files}
\label{sec:lang}

There are several types of configuration 
files and each has different representation. Our goal is to find a good 
intermediary representation that will be language-agnostic. In general,
one can complain that a design of configuration files is pretty low 
level and that we need a new programming language for them. We agree with 
that assertion, and actually our intermediary representation can be seen
as a new programming paradigm for writing configuration files, but this
is not the focus of this proposal. Previously, Huang {\em et al.}~\cite{huang15confvalley} proposed a 
language, ConfValley, to validate 
whether given configuration files meet administrators' specifications. 
However, ConfValley cannot check for misconfiguration checking 
capability, since it is only a library. In ConfValley the administrator 
still needs to write specifications manually, which is an error-prone
process. On the contrary, \app does not require users to manually
write anything.

The translator is a part of \app. It takes as input a sample dataset of configuration files and transforms it into another set of files written in a
typed and well-structured form.
The translator can be seen a parser, and it is
used to translate files into an intermediate representation.

Translating or parsing is system dependent. In other words, for MySQL
and HDFS, we need to develop different parsers to handle each of them,
respectively. Configuration files mainly consists of assignments of the form {\tt {keyword = value}}. Our first attempt was to simply
translate every key-value entry {\tt {k = v}} into a triple $(k, v, \tau)$, where $\tau$ is a type of 
$v$. However, sometimes we could not fully determine the type of key 
based on a single example value. For this reason, we introduced {\emph {probabilistic types}}.

Consider the following example.
\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
foo = 300
bar = 300.txt
\end{lstlisting} 
Most likely {\tt foo} should be an integer, but it could also be a string.
In the second case, we can learn the rule stating 
$ \texttt{foo} \in \textsf{substrings}(\texttt{bar})$. 
Instead of assigning one type to a value, the translator assigns a distribution of types 
to a value, an idea closely related to existentially quantified 
types~\cite{Launchbury93lazyfunctional}. 

Formally, we define probabilistic types as follows: let $\mathcal{T}$ be a set of basic types (cf. Table~\ref{table:kysymys}).
A probabilistic type built from $\mathcal{T}$ is a list of pairs 
$[(\tau_1, p_1),\ldots,(\tau_n, p_n)]$,
such that $\tau_i \in \mathcal{T}$, $0 \le p_i \le 1$ 
and $\Sigma p_i = 1$. 
These probabilities are updated each time a new example value 
for a key is encountered.

When a value has a probabilistic type, we generate rules for all its types.
This means that by assigning {\texttt{foo}} a probabilistic type 
(\eg, {\tt (\texttt{foo}, 300, [(\textsl{Int},90\%), 
(\textsl{String},10\%)])},
we would generate rules for both strings and integers.
Once the type inference can uniquely determine the type, 
the probability of all other types is set to zero, 
and the associated rules are withdrawn. With the help of probabilistic types, we addressed ambiguities during the parsing phase. 

In \app, the set $\mathcal{T}$ should contains strings, integers, file paths, 
sizes, and IP addresses. With every type, we associate a list of templates 
that are used to learn the rules about those files. Table~\ref{table:kysymys} contains
the most important types and templates.

\begin{table}
\caption{Table of types, along with associated templates, used in \app}
  \begin{tabular}{| l |  l |}
    \hline
    Type &  Template \\ \hline
    \hline
    Integer & $X = Y, X\neq Y, X \leq Y, X < Y, X * Y < Z, \ldots $\\ \hline
    String & $\textsf{substr}(U, V), \textsf{prefix}(U,V), \textsf{suffix}(U,V), \ldots$   \\ \hline
    File Path & $\textsf{isFile}(F), \textsf{isDir}(D),\ldots$   \\ \hline
    Size & Similar to integers   \\ \hline
    Port & $P_1 > P_2$ \\ \hline
    IP Addr.  & $\textsf{sameSubnet}(addr1, addr2)$   \\
    
    \hline
  \end{tabular}
\label{table:kysymys}
\end{table}

In general, the templates works as follows: if there are two entries ${\tt {k1 = v1}}$ and 
${\tt {k2 = v2}}$, and let $t(X, Y)$ be a template that can be applied to those values (w.r.t. their types).
If $t(v1, v2)$ holds, \ie, the template condition is valid for those concrete values, then we will add a rule
$t(k1, k2)$ to a list of potentially correct specifications. Note that the rule expresses a relation between keywords, and not values.

Another problem that we need to address
is that configuration files sometimes contain a simple version of the {\tt {if-then}}, such as in Apache HTTPD, that 
sets conditions for which an action should be applied. Therefore, we also add this guard $g$ to our entry 
during the parsing phase. 

With guards in the picture, when instantiating the rules, we first check
 if the guard is true. If it is not, we simply skip that entry.

To summarize, the translator translates every entry ${\tt {k = v}}$ in a configuration file into a quadruple entry
$$(g,k,v,\textsf{List}[p_1:\tau_1, \ldots, p_n:\tau_n])$$

