\section{Motivation}
\label{sec:intro}

Configuration errors are one of the most important root causes of
today's software system failures~\cite{xu15systems, yin11anempirical}.
We read in the news that recently there was a problem in accessing  
Facebook and Instagram~\cite{mashableNews}, 
and a Facebook spokeswoman reported that 
this was caused by a change to the site's configuration systems.
In a recent software system failures study~\cite{yin11anempirical},
researchers revealed that about 31\% of system failures were caused by 
configuration errors, which is higher than the percentage of
failures resulting from program bugs (20\%). 
%(which and only 20\% were caused by bugs in program code 
%While program verification is mostly focused on detecting errors 
%in code, in their empirical study 
%Yin {\em et al.}~\cite{yin11anempirical} report
%that about 31\% of system failures were caused by configuration errors problems and only 20\% were caused by bugs in program code. 
Configuration errors are commonly known in literature 
under the name misconfigurations. 

Misconfigurations, in practice, may result in various
system-wide problems, such as security vulnerabilities, 
application crashes, severe disruptions in software
functionality, and incorrect program executions%
~\cite{zhang14encore, yuan11context, xu13do, xu15hey}. 

The systems research community has recognized this as an important
problem. In fact, at this year's OSDI conference (Operating Systems
Design and Implementation, a top-tier system conference) a paper on
detecting configuration errors~\cite{xu16early} received the best paper 
award. While many efforts have been proposed to check, troubleshoot, diagnose, and repair configuration errors~\cite{attariyan10automating,
su07autobash, whitaker04configuration},
those tools mainly try to understand {\emph{what}} caused the 
error -- they are still not on a level of
automatic verification tools used for regular program 
verification~\cite{Leino10Dafny, PiskacWZ14, BobotFMP15} that can
detect errors without executing the code.

\subsection{Examples}
\label{sec:intro-examples}

We start by presenting two non-trivial configuration errors
extracted from real-world examples. 
Although the errors are relatively simple, we call them 
non-trivial, because the majority of existing misconfiguration
checking tools~\cite{zhang14encore, wang04automatic} cannot detect
these configuration errors. 
Most of the presented examples were found on
StackOverflow~\cite{stackoverflow},
a popular Q\&A website for programmers.

\para{Example~1: Ordering errors.} 
When a user configures PHP  to run with the Apache HTTP Server, most 
likely the user will take some already existing configuration files and 
adapt them to suit her needs. The configuration file might contain, among 
others,  the following lines:
\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
extension = mysql.so
...
extension = recode.so
\end{lstlisting} 
In that case the configuration file will cause the Apache server to 
fail to start due to a segmentation fault error. 
This is because, when using PHP in Apache, the extension {\tt mysql.so} 
depends on {\tt recode.so}, and their relative ordering
is crucial. This is an example of so-called {\em ordering error}.
Yin {\em et al.} report that ordering errors widely exist in
many system configurations, \eg, PHP and MySQL,
and typically lead to multiple system crash events.
However, no existing tool in the systems research can effectively solve 
or detect this problem~\cite{zhang14encore, xu15systems, xu13do}.


\para{Example~2: Fine-grained value correlation error.} 
Next example also comes from a discussion on 
StackOverflow~\cite{correlation}.
The user has configured her MySQL as in the following:
\begin{lstlisting}[language=C, xleftmargin=.01\textwidth]
key_buffer_size = 384M
max_heap_table_size = 128M
max_connections = 64
thread_cache_size = 8
...
sort_buffer_size = 32M
join_buffer_size = 32M
read_buffer_size = 32M
read_rnd_buffer_size = 8M
...
\end{lstlisting} 
The user then complained that her MySQL load was very high, causing the website's
response speed to be very slow.
In this case, {\tt key\_buffer\_size} is used by all the threads
cooperatively, while {\tt join\_buffer} and {\tt sort\_buffer} are 
created by each thread for private use; thus, the maximum amount
of used key buffer, \ie, {\tt key\_buffer\_size}, should be larger than 
{\tt join|sort\_buffer\_size} * {\tt max\_connections}. 
Clearly, in the above example, it does not hold, 
so this misconfiguration causes MySQL to load very slowly.
This type of error is more sophisticated than the simple value correlation that some tools can detect~\cite{yin11anempirical, zhang14encore}.


\subsection{Challenges}
\label{sec:intro-chal}

We believe there are two main obstacles 
why we cannot simply apply the existing automatic 
tools and techniques to verification of configuration files are:
\begin{itemize}
\item a lack
of a specification describing properties of configuration files
\item a program structure of configuration files -- they
are mainly a sequence of entries assigning some value to system
variables (called {\emph {keywords}}). 
\end{itemize}
The language in which configuration files are written does 
not adhere to a specific grammar or syntax. In particular, the
entries in configuration files are untyped. Moreover, there are surprisingly few rules specifying constraints on entries and there
is no explicit structure policy for the entries.
We believe that those are the reasons why there is no automated verification of configuration 
files although the system community expressed that that would be highly
desirable~\cite{wang04automatic, zhang14encore, xu15systems}.


\subsection{Automated Verification of Configuration Files}
\label{sec:intro-goal}

The goal of this proposal is to develop a fully {\bf {automated 
verification  framework for general software configurations}}. We plan to
overcome the above obstacles by first automatically inferring a
specification for configuration files. It is unrealistic to expect the 
users to write an entire specifications for configuration files on their own. 
This process can easily lead to incomplete or even contradictory 
specifications. Instead, we will learn specification from 
a large sample of 
configuration files. A learning process will take as input this 
sample. The process will be language-agnostic and should work for any kind 
of configuration files,  but all of the files in the sample need to be of 
the same kind (such as MySQL or 
HTTPD configuration files). From that sample, we will learn an abundant set of rules 
specifying various properties that hold on the given sample. The rules, in general, 
specify which properties keywords in configuration files need to satisfy. One can see this learning process as 
a way of deriving  a specification for configuration files. With these  rules we can efficiently check 
the correctness of the configuration files of interest and detect 
potential errors. Errors are reported if the configuration file does not 
adhere to a specification.

For practical purposes we plan to use a real-world dataset~\cite{configdataset}. The 
files in the sample might contain
errors, but they are typically different errors and only appear in a small percentage of 
files. We will, therefore, use probabilistic learning to derive a set of accurate rules. 

Building such an automatic verification framework for
configuration files requires addressing several challenges. 
First, in the process of inferring a specification, we have to 
analyze mainly with an untyped, unstructured sequence of assignments.
Thus, we need to develop a suitable language model. We do that by 
``guessing'' a type of keywords and then deriving formulas that
describe relationships between these keywords. However, the
type of a keyword cannot always be fully determined 
from a single value. 
An entry {\tt general\_log = 1} in a MySQL configuration file assigns an integer to the 
keyword {\tt general\_log}. However, 1 here is a Boolean variable,
which denotes that there will be a general log file.
Another example, which often appears in practice, shows how keyword names and 
their ``types'' can easily lead to an error. Consider the
following entry {\tt general\_log = /var/log/mysql/mysql.log}. Although this statement 
alone might look correct, this is actually a typing error and as a result MySQL log cannot be correctly written.

Second, we will learn patterns describing keywords and their relations. We will associate with each type a set of very general templates. The user does not need to provide any templates -- they are internally associated to the types.
Nevertheless, in addition to those general templates, we still need specific algorithms to learn
rules that cannot be easily templated (such as ordering rules). 

We will implement this verification framework and call it \app (for continuity reasons
-- our preliminary tool was called ConfigC, cf. next section).
