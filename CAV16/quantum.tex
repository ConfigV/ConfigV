\section{Quantum Types}

Because our type inference is based on machine learning, we cannot be sure that a keyword unambigously has a single type.
This is an issue when we try to learn relational rules between keywords.
Take the following file in the learning

foo = 300
bar = 300.txt


We want to learn the rule that $foo \in {substring(bar)}$, however using unambigous type inference, we would assign foo type int, and never try to generate a string relation rule for these two keywords.
By assigning foo a quantum type (e.g. ${Int <90\%>, String <10\%>}$), we can now generate rules for both types.

At runtime, when the user wants to check a file we update the probabilities one last time then 'collapse' the quantum type to a concrete type.
If the concrete type collapses to a Int, we consider the rules for ints, and vice versa.

This idea is closely related to exstentially quantified types.
