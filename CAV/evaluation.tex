\section{Implementation and Evaluation}

\para{Implementation.}
\app is implemented in Haskell and takes full advantage of its polymorphism to make the system more modular.
In particular, rules are represented as a type, where the type must support a particular interface (called a typeclass in Haskell) to be compatible with our system.
By using language extensions (FlexibleInstances and MultiParamTypeClasses), this typeclass can be made polymorphic over the data structure as denoted by \lstinline{Foldable t =>}.
The user can then choose a data structure that is most natural to the rule they are implementing.
For example, in our implementation, Missing Entries were easier to manipulate in lists, while Type Errors fit more naturally into a hashmap.
This typeclass defines the three functions that each set of rules must implement to work with our system. The core learning algorithm is simply a fold using \lstinline{merge} over the derived rules from running \lstinline{learn} on each file in the learning set.

Typeclasses and other features of Haskell means that our system consists of only 267 lines of code, with another 233 for the rule modules.
With an average size of 58 lines of code for each rule module, this is evidence of how simple it is to extend \app with new rules.

\begin{lstlisting}
class Foldable t => RuleSet t a where
  learn :: IRConfigFile -> t a
  merge :: t a -> t a -> t a
  check :: t a -> IRConfigFile -> Error
\end{lstlisting}

Since we learn a set of rules on each file in isolation from the other, we have a pleasingly parallel situation.
Haskell allows us to easily take advantage of this by using the parallel
mapping library \cite{parallel}, both for translation to the intermediate representation, and for learning the rules on each file.
The merge stage could also easily be parallelized, using a divide and conquer approach, but \app runs fast enough over our learning set (28 files, 961 lines of code) that this has not been necessary.

The integer relation rule has an unusual implementation that uses function as first-class objects in Haskell.
Rather than associated keywords with SMT formula, we directly associate them with a function of type (\lstinline{Int->Int->Bool}).
Since we need to compare rules over equality, we must have a way to compare functions.
This limits the types of functions we use to \lstinline{(==),(>=),(<=)}.
Although this is sufficient for most cases, more fine-grained relations could be encoded with SMT formulas then passed to a solver.

The tool is available for download at \url{marksantolucito.com/cavae.html}.


\para{Evaluation.}
To evaluate our tool, we take a subset of 20 benchmarks from an
existing dataset of configuration errors~\cite{yin11anempirical,xu15hey,configdataset} which are supported by our tool. Table~\ref{table:res} contains an evaluation summary.
We do not report the running times, since they are negligible: even when
 running in the interpreter mode, files are analyzed instantaneously. We
spent approximately 30 second on learning the rules. When we run the
compiled version, we need for learning and verification 
combined less than 5 seconds. Our focus is usefulness of the tool: its 
 ability to detect configuration errors and the number of false positives.
 For every benchmark class we took five examples. The middle column represents the number of detected errors, while the right column represents the number of returned false positives per each benchmark.
 


\iffalse{
We take the subset of benchmarks for which our tool has implemented rule modules.
Although our tool is general and extensible, we have only implemented four types of rules over the MySQL configuration language.
It would not make sense to run \app on misconfigurations for which there are no rule modules.}
\fi

A benchmark passes a test if it reports an error on the source of the misconfiguration (it is not a false negative).
We call false positives any reported error that was unrelated to the value of interest.
It is worth noting that this is in fact a conservative estimate.
Since these benchmarks are taken from online forums, there is no guarantee the files contain only a single error.
Indeed, on some benchmarks, \app found errors in the file that were similar to rules broken by other benchmarks. 

We fail one benchmark in Value Relations because we do not yet support relations between file sizes of different units (Mb to Kb).
In one Keyword Ordering benchmark, \app reports a type error on the value of interest instead of an ordering error.
This is a result of our context embedding in the translation to the intermediate representation - reordering the value puts it in a new context where the type is now also incorrect.

\begin{table}[t]
\centering
\caption{Benchmarks for misconfiguration detection}
\label{table:res}
\begin{tabular}{|l|l|l|}
\hline
Error Type       & Passing Tests & False Positives  \\ 
\hline
\hline
Missing Entry    & 5/5           & 1, 0, 0, 0, 4        \\ \hline
Type Error       & 5/5           & 0, 0, 0, 0, 0          \\ \hline
Keyword Ordering & 5/5           & 0, 2, 1, 0, 6       \\ \hline
Value Relations  & 4/5           & 0, 0, 0, 1, 0        \\ 
\hline
\end{tabular}
\end{table}

All but one false positive reports were integer relations. They are the
result of overfitting on rules.
\app can learn overapproximating rules when the learning set does not show the full spectrum of possible values.
Since integer relations have a larger space of relation than ordering relations for instance, \app needs a larger learning set in order to eliminate false positives.

The false positive for the Value Relation was a Missing Entry error.
This is a result of the fact that we cannot learn rules that are disjunctions.
In this case, no socket is provided to [mysqld], failing a rule we had learned over the dataset.
In fact, this is not a misconfiguration because a socket only needs to be provided to one (or both) [mysqld] or [wampsqld].
We reported an error since none of the files in the learning set had no socket associated with [mysqld].
In fact, since we do not support disjunctive rules, we could not have even learned such a rule - though in practice these seem to be uncommon.

