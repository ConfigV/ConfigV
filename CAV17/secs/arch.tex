
\section{The \app Framework Overview}

\begin{figure*}[tbp] \centering
\includegraphics[width=0.84\textwidth]{figs/overview}
\caption{\app's workflow. The green components represent configuration 
  files, including both training set of configuration files and users' input
  configuration files to verify.
  The blue dashed box is \app. 
  The yellow components are key modules of \app.
  The purple circle is a checker for checking whether the target
  configuration file violates any rule.}
\label{fig-overview}
\end{figure*}

We propose \app, an automatic verification framework for 
software configuration files.
As shown in Sec.~\ref{sec-motiv}, \app can detect many sophisticated 
configuration errors, including ordering errors, missing entry errors,
type errors and integer correlation errors. 
Figure~\ref{fig-overview} shows
a typical \app verification workflow with three steps:
translation, learning, and rule refinement. This section briefly
describes how each step works.

\para{Initial phase}
We start with the assumption 
that we are given a number of (not necessarily correct) 
configuration files, called {\em training set}, 
belonging to the same system, such as MySQL or Apache. 
These files, therefore, follow similar patterns.
%In the following steps,
%we will exploit in a collection of learning algorithms 
%to build rules that describe a language model for the files.

\para{Translator}
The translator module first parses the input training  
set of configuration files, and then transforms them into 
a more structured and typed intermediate representation.
When we infer the types of entries in a configuration file, 
the type of an entry cannot always be fully determined from 
a single value, since it is difficult to understand
the purposes of key-value entries in modern
software configuration files~\cite{xu15hey}.
We address this problem 
by introducing {\em probabilistic types}.
Rather than giving a variable a single type, 
we assign several types over a probability distribution. 
We can later use these well-structured files
as a ``true'' training set to learn the rules. 

\para{Learning}
The learner reads a set of configuration  files that have been translated
into well-structured representations. 
The learner employs a learning algorithm, {\em rule association 
algorithm}, to generate various rules,
potentially used to handle different types of configuration errors,
including ordering errors, missing entry errors,
type errors and integer correlation errors.
These rules are the outputs of the learner, 
and will be used to detect errors later.
Because the translator gives the learner probabilistically typed entries,
the learner is also responsible for determining types for these entries.

\para{Post Analysis}
Finally, the logically structured representation of learned rules allows for a further post analysis stage.
This novel extension infers knowledge on the accepted rules that can improve the output of the system.
As a case study, we build a graph to model the learned rules.
We analyze the properties of this graph to construct an ordering of rules by their importance, 
  as well as to produce a measure of complexity for any configuration of the target system.
While the metrics in used in \app are effective, they are not intended to be exhaustive.
The information contained in the structured representation of the learned rules, 
  is a unique benefit of the learning algorithm, as contrasted with other machine learning techniques.

