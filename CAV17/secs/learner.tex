\section{Learner}
\label{sec-learn}

The goal of the learner is to derive rules from the intermediate representation of the training set generated by the translator.
We describe an interface to define the different classes of rules that should be learned.
Each instance of the interface corresponds to a different class of of configuration errors, such as missing entry errors, ordering errors, and integer correlation errors. 
These errors can cause total system failures, but can also be more insidious, for example slowing down the system only when the server load increases beyond a certain threshold.

%TODO define rule

We use an approach similar to \textit{association rule learning}~\cite{agrawal1993mining}, a technique that can be summarized as inductive machine learning.
Association rule learning is best suited to learn rules over sets of keys, which in the configuration domain are integer correlation and missing keyword rules.
Sequence mining~\cite{} is a more appropriate technique for learning ordering rules, and again another approach may be a better fit for rules over a single keyword, as is needed for probabilistic types.
We highlight here only two key metrics from these approaches that are most relevant to verification tasks; \textit{support} and \textit{confidence}.

Support is the number of times the set of keywords in the proposed rule will be 
Confidence is 

\para{Order}

\para{Missing}

\para{Type}
In \app, probabilistic typing is implemented as an instance of the learning interface than can be easily extended to support more types. 
It 

\para{Integer Correlation}
Fine grained errors (Aaron)

\subsection{Checker}
\label{sec-checker}

With the learned rules and constraints in hand (generated
by the learner module),
\app checks whether any entry in a target configuration file
violates the learned rules and constraints.
For a given configuration file, \app parses it the same
way employed in the translator, thus obtaining a structured
and typed representation for the target configuration file.
Then, the checker uses two sub-modules (shown in 
Figure~\ref{fig-overview}) to check the target
configuration file based on rules and constraints.

\subsection{Implementation}

\app is primarily implemented in Haskell, with a bit of mongo.
The translator is developed as a parser for the grammar described in $\S$\ref{sec-trans}. 
The learner and checker module fully implemented the design in $\S$\ref{sec-learn} and $\S$\ref{sec-checker}, respectively. 
 
The learning and checking modules are developed to allow
for customized extensibility. In order to verify a configuration file
against a new type of error, a user only needs to provide a new type
that is an instance of the \textit{Attribute} typeclass (\ie, define some
functions over that type). 
In particular, for each type of error the users
wish to detect, they must implement three functions;
\lstinline{learn}, \lstinline{merge}, and \lstinline{check}.

The source code for our implementation is available at {\em (URL omitted for blind review)}.
