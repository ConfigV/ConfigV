
\section{Discussion and Limitations}

This section discusses a few of \app's limitations
and possible solutions.

%TODO move this - it is not a limitation
\para{Legal misconfigurations}
Most of the existing proactive misconfiguration detection techniques, cannot handle configuration errors resulting from events that occurred during system runtime.
Such configuration errors are referred to as {\em legal misconfigurations}~\cite{yin11anempirical}. 
In particular, many parameter misconfigurations have perfectly legal types and values, but do not deliver the functionality intended by users. 
For example, after a website's traffic significantly increases, the parameter {\tt key\_buffer\_size} in MySQL may not  be able to handle increasingly more data traffic,
   thus leading to outage of the whole system.
While \app does not explicitly use any runtime information, we are still able to detect such errors, for example Sec.~\ref{ex:fine}.
Since \app relies on the collective knowledge of the training set, as long as the training set is mostly correct with respect to legal misconfigurations, these can still be detected.

\para{Misconfiguration across software components}
As reported by Yin {\em et al.}~\cite{yin11anempirical},
cross-software configuration correlation problems also account
for a considerable number of misconfiguration cases.
For example, in a LAMP-based Web server, one entry in the
PHP configuration file, {\tt mysql.max\_persistent = 400},
may make users encounter a ``too many connections'' error,
because a correlated entry in the underlying MySQL configuration
file assigns {\tt max\_connection} to 300, which is less
than the MySQL connection number in the PHP configuration file (\ie, 400).
It is quite difficult to detect such tricky errors
through learning approaches, because not only are users or engineers 
unaware of the hidden interactions~\cite{xu15systems},
but also it is hard to obtain global knowledge of the entire
configuration due to the business privacy concerns of
each software provider.
One possible solution to this problem might be to introduce
some cryptographic protocol, \eg, private set
intersection~\cite{kissner05privacy}, to privately extract the
overlapping entries, \eg, {\tt mysql.max\_connection} in the 
above MySQL and PHP case, for double-checking.

\para{Network configuration verification}
\app mainly focuses on software configurations, \eg, MySQL and Apache,
so that our approach is limited to support network configuration
verification. This is because network configurations have quite
different representations, format, and rules from software configurations,
since network configurations are typically written in 
more domain-specific policy languages.
In fact, many network verification tools, 
\eg, NoD~\cite{lopes15checking} and 
Dobrescu {\em et al.}~\cite{dobrescu14software},
have been proposed to check whether network configurations
meet their specifications.

\para{More complex configuration structure}
Currently, \app mainly targets key-value configuration files,
but in practice many systems, \eg, OpenStack~\cite{OpenStack},
employ very complex configuration format and structure,
which \app cannot handle.
Verifying such structurally complex configurations typically requires 
\app to learn a much more sophisticated language model,
which is challenging in practice.
Recent efforts~\cite{raychev15predicting, raychev16learning} 
may present possible solutions to this limitation.
These techniques can learn a call-graph from a training program set,
and check a new program based on properties extracted from this
generated call-graph. If we examine a structurally complex configuration 
file as a program with these tools, we may be able to use similar techniques 
to verify whether the configuration file violates a property of interest. 
