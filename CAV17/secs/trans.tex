
\section{Translator}
\label{sec:trans}

The translator takes as input a training set of configuration files and transforms it into a typed and well-structured intermediate representation.
The translator can be seen a parser used to generate an intermediate representation for the learner module (cf. Sec.~\ref{sec-learn}).
Translating or parsing is system dependent since each configuration language (MySQL, Apache, PHP) uses a different grammar.
\app allows users to provide extra help to the translator for their specific system configurations.

The translator converts each key-value assignment $k=v$ in the configuration file to a triple $(k, v, \tau)$, where $\tau$ is the type of $v$. 
There are two major challenges in this step.
First is that configuration files' keywords are not necessarily unique and may have some additional context (modules or conditionals).
To solve this, we rely on the fact that keywords in a configuration file must be unique within their context, and rename all keywords with their context.
The set of unique keys, $\keys$, for the sample training set in Figure~\ref{fig:tset} would then be [``{\tt foo[server]}'',``{\tt bar[client]}''].

{
\setlength{\belowcaptionskip}{-15pt}
\begin{figure}[!htb]
    \centering
    \begin{minipage}{.25\textwidth}
	\begin{lstlisting} [label={lst:file1.cnf},language=C,caption={file1.cnf}]
[server]
foo = ON
[client]
bar = 1
	\end{lstlisting}
    \end{minipage}%
    \hspace{1cm}
    \begin{minipage}{0.25\textwidth}
	\begin{lstlisting} [label={lst:file2.cnf},language=C,caption={file2.cnf}]
[server]
foo = ON
[client]
bar = ON
	\end{lstlisting}
    \end{minipage}
    \hspace{1cm}
    \begin{minipage}{0.25\textwidth}
	\begin{lstlisting} [label={lst:file3.cnf},language=C,caption={file3.cnf}]
[server]
foo = OFF
[client]
bar = OFF
	\end{lstlisting}
    \end{minipage}
    \caption{A sample training set of configuration files}
    \label{fig:tset}
\end{figure}
}

\para{Probabilistic Types}
%\label{sec:ptypes}
An additional challenge is that it is not always possible to fully determine the type of key based on a single example value. 
For this reason, we introduce \textit{probabilistic types}, as contrasted with \textit{basic types}.
In \app, the set of basic types contains strings, file paths, integers, sizes, and Booleans. 
Taking the configuration \ref{lst:file1.cnf}, we can assume {\tt foo} is a Boolean type by the grammar of MySQL,
  but the keyword {\tt bar} could many types.
If we choose the type on the first example it will be a integer type, if we choose a type that fits all examples it will be a string, or we might somehow select the Boolean type.
Let us assume that there is a critical rule we must learn that the Boolean keywords should have the same values, $eq(\texttt{foo},\texttt{bar})$.
If we take {\tt bar}$::int$, we do not learn the above rule, nor do we learn this rule with {\tt bar}$::string$ - only with {\tt bar}$::bool$ is the rule is valid.
To resolve this ambiguity, and choose the best type, the translator assigns a distribution of types to a keyword based on examples from the training set (denoted \trainingSet).

A probabilistic type is a set of counts over a set $\mathcal{T}$ of basic types.
Formally, we define a space of probabilistic types $\tilde{\mathcal{T}}$, where $\ptype \in \tilde{\mathcal{T}}$ has a form $\ptype=\{(\tau_1, c_1),\ldots,(\tau_n, c_n)\}$, such that $\tau_i \in \mathcal{T}$, $c_i \in \mathbb{Z}$. 
Every keyword $k \in \keys$ has a probabilistic type, expressed $k:\ptype$, as opposed to the basic type notation $k::\tau$.
The count for $(\tau_i,c_i) \in \ptype$ should be equal to the number of times a key in \trainingSet has a potential match to type $\tau_i$.
%We also denote the set of key-value pairs with $C$ and a keyword value pair that exists in some configuration file as $(k,v) \in C$.

Fig.~\ref{fig:ptypes} provides a calculus for type judgments for deriving equality rules with probabilistic types.
We use the notation $\ptype[\tau=N]$ to create a probabilistic type with the count of $N$ for $\tau$ in {\scriptsize PTYPE}.
This rule simply counts the regex matches for each key value pair.
In the {\scriptsize BOOL} judgment, a keyword with a probabilistic type $k : \ptype \in \tilde{\mathcal{T}}$ can be resolved to the basic type $bool$ when the $\ptype$ satisfies the predicate $p_{bool}$, \ie\ the probabilistic type has enough evidence.
The definition of enough evidence must be empirically determined by the user depending on the quality of the learning set.

{
\setlength{\abovecaptionskip}{-.05pt}
\setlength{\belowcaptionskip}{-15pt}
\begin{figure}
\begin{mathpar}
\hspace{-1cm} %no idea why, but this is better than \centering here
\inferrule* [Right=ptype]
{c_{int} = |\{\forall C \in \trainingSet.\ \forall (k,v) \in C.\ v \in \mathbb{Z}\}| \\ c_{bool} = |\{\forall C \in \trainingSet.\ \forall (k,v) \in C.\ v \in \{0,1,ON,OFF\}\}| }
{k : \ptype[int = c_{int}, bool = c_{bool}]}
\and\\
\inferrule* [Right=int]
{k:\ptype \\ p_{int}(\ptype)}
{k :: int}
\and
\inferrule* [Right=bool]
{k:\ptype \\ p_{bool}(\ptype)}
{k :: bool}
\and
\inferrule* [Right=eq\_rule]
{k_1 :: \tau \\ k_2 :: \tau}
{eq(k_1,k_2) :: Rule}
\end{mathpar}
\caption{Type judgments for a probabilistic type system with $\mathcal{T} = \{bool,int\}$ and an equality rule}
\label{fig:ptypes}
\end{figure}
}

In order to define predicates, we use the notation $|\tau_i\ptype|$ to select $c_i$ from a $\ptype \in \tilde{\mathcal{T}}$.
As an example, we can set the predicate $p_{bool}(\ptype)= |bool\ptype| \geq 3 \land |int\ptype| \leq 1$,
Then taking these type inference rules above, we can run an example inference on the sample training set in Figure~\ref{fig:tset}.
The resultant probabilistic type \texttt{bar}$:[bool=3,int=1]$ is then resolved to \texttt{bar}$::bool$.
 
A user may pick predicates for probabilistic type resolution that result in overlapping inference rules.
For example, if a user picks $p_{int}(\ptype)= |int\ptype| \geq 1$, then {\scriptsize INT} overlaps with {\scriptsize BOOL}.
To resolve the ambiguity in this case we must add a new rule {\scriptsize INTBOOL} that introduces a new type $intbool$.
This type is only a place holder to be used in the additional subtyping relations $intbool <: int$ and $intbool <: bool$.
These subtype relations allow the $intbool$ to take the place of either $int$ or $bool$ when determining if two keyswords may be compared in the {\scriptsize EQ\_RULE}.

\begin{mathpar}
\hspace{-0.8cm} %no idea why, but this is better than \centering here
\inferrule* [Right=intbool]
{k:\ptype \\ p_{bool}(\ptype) \\ p_{int}(\ptype)}
{k :: intbool}
\and
\inferrule* [Right=order\_rule]
{k1,k2 \in C \\ k1 \neq k2}
{ord(k1,k2) :: Rule}
\end{mathpar}

In the case that there is not enough evidence to resolve a probabilistic type to a basic type, no type-dependent rules may be learned over that keyword.
However, we are still able to learn rules such as {\scriptsize ORDER}, which do not require any resolved type. 



