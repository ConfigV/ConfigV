
\section{Translator}
\label{sec-trans}

The translator takes as input a sample dataset of configuration files and transforms it into a typed and well-structured intermediate representation.
The translator can be seen a parser used to generate an intermediate representation for learning rules (see $\S$\ref{sec-learn}).
Translating or parsing is system dependent since each configuration language (MySQL, Apache, PHP) uses a different grammar.
\app allows users to provide extra help to the translator for their specific system configurations.

The translator will convert each key-value assignment {\tt k=v} in the configuration file to a triple, $(k, v, \tau)$, where $\tau$ is a type of $v$. 
There are two major challenges in this step.
First is that configuration files' keywords are not necessarily unique and may have some additional context (modules or conditionals).
To solve this, we rely on the fact that keywords in a configuration file must be unique within their context, and rename all keywords with their context.
They keys for the sample configuration \ref{lst:mysql.cnf} would then be [``{\tt foo[server]}'',``{\tt bar[client]}''] internally to the intermediate representation.


\begin{lstlisting} [caption={A sample MySQL configuration file},label={lst:mysql.cnf},language=C]
  #mysql.cnf
  [server]
  foo = False
  [client]
  bar = 1
\end{lstlisting}

An additional challenge is that it is not always possible to fully determine the type of key based on a single example value. 
For this reason, we introduce {\emph {probabilistic types}}.
Taking the configuration \ref{lst:mysql.cnf}, we can assume \tt{bar} is a boolean type by the grammar of MySQL,
  but the keyword {\tt bar} could either be a integer type or a Boolean type.
Now considering the rule that the keywords should have the same values ($\texttt{foo}==\texttt{bar}$), we have two potential situations.
If {\tt bar::int}, we do not learn the above rule, but in the second case where {\tt bar::bool}, the rule is valid.
To resolve this ambiguity, instead of immediately assigning one type to a value, the translator assigns a distribution of types to a value based on examples from the learning set.
% an idea closely related to existentially quantified types~\cite{Launchbury93lazyfunctional}. 

Formally, we define probabilistic types as follows: let $\mathcal{T}$ be a set of basic types.
In \app, the set $\mathcal{T}$ contains strings, file paths, integers, sizes, and booleans. 
A probabilistic type is a set of pairs $\{(\tau_1, c_1),\ldots,(\tau_n, c_n)\}$, such that $\tau_i \in \mathcal{T}$, $c_i \in \mathbb{Z}$. 
The count for $\tau_i$ is incremented each time a new example value that might be type $\tau_i$ is encountered for a particular key.

For example, if the training set contained [(``bar",1),(``bar",ON)], the resulting type would be bar::[bool=2,int=1] (considering that the literal 1 may act as either an int or a boolean).
This probabilistic type can then be collapsed in the final type inference stage based on domain knowledge of the types and the training set.
For instance, we might choose to treat bar as a boolean, and only learn rules on that rule type.
We could also choose to leave the type unresolved for lack of evidence, and learn rules on both types.

Note that in \app, typing is implemented as a learning module than can be easily extended to support more types. 



