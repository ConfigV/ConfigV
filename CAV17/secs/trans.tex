
\section{Translator}
\label{sec-trans}

The translator takes as input a sample dataset of configuration files and transforms it into another set of files written in
typed and well-structured representations.
The translator can be seen a parser, and it is only
used to generate an intermediate representation for post-processing, 
such as learning rules (see $\S$\ref{sec-learn}).
Coupled with rules generated by learner module,
we will have a complete language model to verify configuration files
of our interest.

Translating or parsing is system dependent. In other words, for MySQL
and HDFS, we need to develop different parsers to handle each of them,
respectively. \app allows users to 
provide extra help to the translator
for their specific system configurations,
but it is not required.

The majority of entries in a configuration files are assignments. Our first attempt was to simply
translate every key-value entry {\tt {k = v}} into a triple $(k, v, \tau)$, where $\tau$ is a type of 
$v$. However, sometimes we could not fully determine the type of key 
based on a single example value. For this reason, we introduced {\emph {probabilistic types}}.

Consider the following example.

\noindent{\tt {foo = 300}}\\
{\tt {bar = 300.txt}}

Most likely {\tt foo} should be an integer, but it could also be a string.
In the second case, we can learn the rule stating 
$ \texttt{foo} \in \textsf{substrings}(\texttt{bar})$. 
Instead of assigning one type to a value, the translator assigns a distribution of types 
to a value, an idea closely related to existentially quantified 
types~\cite{Launchbury93lazyfunctional}. 

Formally, we define probabilistic types as follows: let $\mathcal{T}$ be a set of basic types (cf. Table~\ref{table:kysymys}).
A probabilistic type built from $\mathcal{T}$ is a list of pairs 
$[(\tau_1, p_1),\ldots,(\tau_n, p_n)]$,
such that $\tau_i \in \mathcal{T}$, $0 \le p_i \le 1$ 
and $\Sigma p_i = 1$. 
These probabilities are updated each time a new example value 
for a key is encountered.

When a value has a probabilistic type, we generate rules for all its types.
This means that by assigning {\texttt{foo}} a probabilistic type 
(\eg, {\tt (\texttt{foo}, 300, [(\textsl{Int},90\%), 
(\textsl{String},10\%)])},
we would generate rules for both strings and integers.
Once the type inference can uniquely determine the type, 
the probability of all other types is set to zero, 
and the associated rules are withdrawn.

In \app, the set $\mathcal{T}$ contains strings, integers, file paths, 
sizes, and IP addresses. With every type, we associate a list of templates 
that are used to learn the rules about those files. Table~\ref{table:kysymys} contains
the most important types and templates.

\begin{table}
\caption{Table of types, along with associated templates, used in \app}
  \begin{tabular}{| l |  l |}
    \hline
    Type &  Template \\ \hline
    \hline
    Integer & $X = Y, X\neq Y, X \leq Y, X < Y, X * Y < Z, \ldots $\\ \hline
    String & $\textsf{substr}(U, V), \textsf{prefix}(U,V), \textsf{suffix}(U,V), \ldots$   \\ \hline
    File Path & $\textsf{isFile}(F), \textsf{isDir}(D),\ldots$   \\ \hline
    Size & Similar to integers   \\ \hline
    Port & $P_1 > P_2$ \\ \hline
    IP Addr.  & $\textsf{sameSubnet}(addr1, addr2)$   \\
    
    \hline
  \end{tabular}
\label{table:kysymys}
\end{table}


In general, the templates works as follows: if there are two entries ${\tt {k1 = v1}}$ and 
${\tt {k2 = v2}}$, let $t(X, Y)$ be a template that can be applied to those values (w.r.t. their types).
If $t(v1, v2)$ holds, \ie, the template condition is valid for those concrete values, then we will add a rule
$t(k1, k2)$ to a list of potentially correct specifications. Note that the rule expresses a relation between variables.

With the help of probabilistic types, we addressed ambiguities during the parsing phase. Another problem that we need to solve
is that configuration files sometimes contain a simple version of the {\tt {if-then}}, such as in Apache HTTPD, that 
sets conditions for which an action should be applied. Therefore, we also add this guard to our entry 
during the parsing phase. We first check if the guard is true before deriving a rule; otherwise, we skip the entry.

To summarize, the translator translates every entity ${\tt {k = v}}$ in a configuration file into a quadruple entry
$$(g,k,v,\textsf{List}[p_1:\tau_1, \ldots, p_n:\tau_n])$$

For an entry $e$, we denote the corresponding guard by $g(e)$, the key by $k(e)$, the value by $v(e)$, and the probabilistic
type list by $typelist(e)$. 

\com{Note that typing is also a system module than 
can be easily extended to support more types. 
In that case the user will need to provide rules for type inference 
and probability distributions for values where type inference is ambiguous.
}
