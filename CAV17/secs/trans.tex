
\section{Translator}
\label{sec:trans}

The translator takes as input a training set of configuration files and transforms it into a typed and well-structured intermediate representation.
The translator can be seen a parser used to generate an intermediate representation for the learner module (cf. Sec.~\ref{sec-learn}).
Translating or parsing is system dependent since each configuration language (MySQL, Apache, PHP) uses a different grammar.
\app allows users to provide extra help to the translator for their specific system configurations.

The translator converts each key-value assignment $k=v$ in the configuration file to a triple $(k, v, \tau)$, where $\tau$ is the type of $v$. 
There are two major challenges in this step.
First is that configuration files' keywords are not necessarily unique and may have some additional context (modules or conditionals).
To solve this, we rely on the fact that keywords in a configuration file must be unique within their context, and rename all keywords with their context.
The set of unique keys, $\keys$, for the sample training set in Figure~\ref{fig:tset} would then be [``{\tt foo[server]}'',``{\tt bar[client]}''].

{
\setlength{\belowcaptionskip}{-15pt}
\begin{figure}[!htb]
    \centering
    \begin{minipage}{.25\textwidth}
	\begin{lstlisting} [label={lst:file1.cnf},language=C,caption={file1.cnf}]
[server]
foo = ON
[client]
bar = 1
	\end{lstlisting}
    \end{minipage}%
    \hspace{1cm}
    \begin{minipage}{0.25\textwidth}
	\begin{lstlisting} [label={lst:file2.cnf},language=C,caption={file2.cnf}]
[server]
foo = ON
[client]
bar = ON
	\end{lstlisting}
    \end{minipage}
    \hspace{1cm}
    \begin{minipage}{0.25\textwidth}
	\begin{lstlisting} [label={lst:file3.cnf},language=C,caption={file3.cnf}]
[server]
foo = OFF
[client]
bar = OFF
	\end{lstlisting}
    \end{minipage}
    \caption{A sample training set of configuration files}
    \label{fig:tset}
\end{figure}
}

\para{Probabilistic Types}
%\label{sec:ptypes}
An additional challenge is that it is not always possible to fully determine the type of key based on a single example value. 
For this reason, we introduce \textit{probabilistic types}, as contrasted with \textit{basic types}.
In \app, the set of basic types contains strings, file paths, integers, sizes, and Booleans. 
Taking the configuration \ref{lst:file1.cnf}, we can assume {\tt foo} is a Boolean type by the grammar of MySQL,
  but the keyword {\tt bar} could either be a integer type or a Boolean type.
Let us assume that there is a rule stating that the Boolean keywords should have the same values ($eq(\texttt{foo},\texttt{bar})$).
Then there are two potential situations; in the first case where {\tt bar}$::int$, we do not learn the above rule, but in the second case where {\tt bar}$::bool$, the rule is valid.
To resolve this ambiguity, instead of immediately assigning one type to a value, the translator assigns a distribution of types to a value based on examples from the learning set.


A probabilistic type is a set of counts over a set $\mathcal{T}$ of basic types.
Formally, we define a space of probabilistic types $\tilde{\mathcal{T}}$, where $\ptype \in \tilde{\mathcal{T}}$ has a form $\ptype=\{(\tau_1, c_1),\ldots,(\tau_n, c_n)\}$, such that $\tau_i \in \mathcal{T}$, $c_i \in \mathbb{Z}$. 
Every keyword $k\in\keys$ has a probabilistic type, expressed $k:\ptype$.
The count for $(\tau_i,c_i) \in \ptype$ is incremented each time a new example value that matches to type $\tau_i$ is encountered for a particular key, using the update notation $\update$.
We also denote the set of key-value pairs with $C$ and a keyword value pair that exists in some configuration file as $(k,v) \in C$.

Fig.~\ref{fig:ptypes} provides a fragment of a calculus for type judgments for deriving Boolean equality rules with probabilistic types.
We use the notation, $\ptype \models p$, to denote a probabilistic type whose counts hold on the predicate $p$. 
For a probabilistic type, $\ptype$, we use the notation $|\tau_i|$ to select from $\ptype$, the $c_i$.
We use $*$ as a wildcard selector for all basic types in a $\ptype$.
When there is no evidence for a type $\tau$ we call this the empty type ({\scriptsize EMPTY}). 
Initially, all keywords are set to the empty set.
In the {\scriptsize BOOL\_RESOLVE} rule, a keyword with a probabilistic type $k : \ptype \in \tilde{\mathcal{T}}$ can be resolved to a basic type with enough evidence.
The definition of enough evidence must be empirically determined by the user depending on the quality of the learning set.

{
\setlength{\abovecaptionskip}{-.05pt}
\setlength{\belowcaptionskip}{-15pt}
\begin{figure}
\begin{mathpar}
\hspace{-1cm} %no idea why, but this is better than \centering here
\inferrule* [Right=Empty]
{\\}
{k:[\ast = 0]}
\and
\inferrule* [Right=bool\_int]
{(k,v) \in C \\ v \in \{0,1\} \\ k:\ptype}
{k:\ptype\update[int\pluseq 1,bool\pluseq 1]}
\and
\inferrule* [Right=bool]
{(k,v) \in C \\ v \in \{ON,OFF\} \\ k:\ptype}
{k:\ptype\update[bool\pluseq 1]}
\\
\and
\inferrule* [Right=bool\_resolve]
{k:\ptype \\ \ptype \models |bool| \geq M \land |\ast| \leq N}
{k :: bool}
\\
\and
\inferrule* [Right=eq\_rule]
{k_1 :: \tau \\ k_2 :: \tau \\ \tau \in \mathcal{T}}
{eq(k_1,k_2) :: Rule}
\end{mathpar}
\caption{Type judgments for Boolean equality rules with probabilistic types}
\label{fig:ptypes}
\end{figure}
}

Taking these type inference rules above, we can run an example inference on the sample training set in Figure~\ref{fig:tset}.
The result is the probabilistic type \texttt{bar}$:[bool=3,int=1]$.
If in this example, the user had set $M=3, N=1$, we resolve the probabilistic type of \texttt{bar} to \texttt{bar}$::bool$.

\ruzica{Mark, please argue better about this}
 
A user may implement overlapping inference rules, for example in {\scriptsize INT\_RESOLVE}.
This not a subtyping relation, as the predicates over the counts may not be strictly overlapping.
%TODO this make no sense - address ambiguity more clearly
We simply allow the double colon (::) to type a single keyword in multiple ways.
Because the only typing judgments on a basic type are terminal, {\scriptsize EQ\_RULE}, there is no problem with ambiguity as we would have in a traditional lambda calculus that included function application.

\begin{mathpar}
\hspace{-0.8cm} %no idea why, but this is better than \centering here
\inferrule* [Right=int\_resolve]
{k:\ptype \\ \ptype \models int \geq 1}
{k :: int}
\and
\inferrule* [Right=order\_rule]
{k1,k2 \in C \\ k1 \neq k2}
{ord(k1,k2) :: Rule}
\end{mathpar}

In the case that there is not enough evidence to resolve a probabilistic type to a basic type, no type-dependent rules may be learned over that keyword.
We are still able to learn rules such as {\scriptsize ORDER}, which do not require any resolved type. 


