
\section{Translator}
\label{sec:trans}

The translator takes as input a training set of configuration files and transforms it into a typed and well-structured intermediate representation.
The translator can be seen as a parser used to generate an intermediate representation for the learner module (cf. Sec.~\ref{sec-learn}).
Translating or parsing is system dependent since each configuration language (MySQL, Apache, PHP) uses a different grammar.
\app allows users to provide extra help to the translator for their specific system configurations.

The translator converts each key-value assignment $k=v$ in the configuration file to a triple $(k, v, \tau)$, where $\tau$ is the type of $v$. 
There are two major challenges in this step.
First is that configuration files' keywords are not necessarily unique and may have some additional context (modules or conditionals).
To solve this, we rely on the fact that keywords in a configuration file must be unique within their context, and rename all keywords with their context.
The set of unique keys, $\keys$, for the sample training set in Figure~\ref{fig:tset} would then be [``{\tt foo[server]}'',``{\tt bar[client]}''].

{
\setlength{\belowcaptionskip}{-15pt}
\begin{figure}[!htb]
    \centering
    \begin{minipage}{.25\textwidth}
	\begin{lstlisting} [label={lst:file1.cnf},language=C,caption={file1.cnf}]
[server]
foo = ON
[client]
bar = 1
	\end{lstlisting}
    \end{minipage}%
    \hspace{1cm}
    \begin{minipage}{0.25\textwidth}
	\begin{lstlisting} [label={lst:file2.cnf},language=C,caption={file2.cnf}]
[server]
foo = ON
[client]
bar = ON
	\end{lstlisting}
    \end{minipage}
    \hspace{1cm}
    \begin{minipage}{0.25\textwidth}
	\begin{lstlisting} [label={lst:file3.cnf},language=C,caption={file3.cnf}]
[server]
foo = OFF
[client]
bar = OFF
	\end{lstlisting}
    \end{minipage}
    \caption{A sample training set of configuration files}
    \label{fig:tset}
\end{figure}
}

\para{Probabilistic Types}
%\label{sec:ptypes}
An additional challenge is that it is not always possible to fully determine the type of key based on a single example value. 
For this reason, we introduce \textit{probabilistic types}, as contrasted with \textit{basic types}.
In \app, the set of basic types contains strings, file paths, integers, sizes, and Booleans. 
Taking the configuration \ref{lst:file1.cnf}, we can assume {\tt foo} is a Boolean type by the grammar of MySQL,
  but the keyword {\tt bar} could be many types.
If we choose the type based on the first example, {\tt bar} will be a integer type.
If we choose a type that fits all examples, {\tt bar} will be a string.
However the correct classification needed is a Boolean type.
For illustrative purposes, let us assume that there is a critical rule we must learn where tow Boolean keywords should always have the same values, \textit{e.g.} $eq(\texttt{foo},\texttt{bar})$.
If we take {\tt bar}$::int$, we do not learn the above rule, nor do we learn this rule with {\tt bar}$::string$ - only with {\tt bar}$::bool$ is the rule is valid.
To resolve this ambiguity, and choose the best type, the translator assigns a distribution of types to a keyword based on examples from the training set of configuration files (denoted $\trainingSet=\{C\}$).
 

A probabilistic type is a set of counts over a set $\mathcal{T}$ of basic types.
Formally, we define a space of probabilistic types $\tilde{\mathcal{T}}$, where $\ptype \in \tilde{\mathcal{T}}$ has the form $\ptype=\{(\tau_1, c_1),\ldots,(\tau_n, c_n)\}$, such that $\tau_i \in \mathcal{T}$, $c_i \in \mathbb{Z}$. 
Figure~\ref{fig:ptypes} provides a calculus for probabilistic types over an example subset of basic types.
This allows us to give a clear definition of the set of possible (\ie well-typed) equality rules.

Every unique keyword $k \in \trainingSet$ has a probabilistic type, expressed $k:\ptype$, as opposed to the basic type notation $k::\tau$.
The count for $(\tau_i,c_i) \in \ptype$ should be equal to the number of times a key in \trainingSet has a potential match to type $\tau_i$.
The judgment {\scriptsize PTYPE} counts, over all files $C \in \trainingSet$, the times the value of a key matches a user defined set of acceptable values for each type $\tau_i \in \ptype$.
We use the notation $\ptype[\tau_i=N]$ to create a probabilistic type with the count of $N$ for $\tau_i \in \ptype$.
%We also denote the set of key-value pairs with $C$ and a keyword value pair that exists in some configuration file as $(k,v) \in C$.

In the {\scriptsize BOOL} judgment, a keyword with a probabilistic type $k : \ptype \in \tilde{\mathcal{T}}$ can be resolved to the basic type $bool$ when the $\ptype$ satisfies the resolution predicate $p_{bool}$, \ie\ the probabilistic type has sufficient evidence.
The definition of sufficient evidence must be empirically determined by the user depending on the quality of the training set.

{
\setlength{\abovecaptionskip}{-.05pt}
\setlength{\belowcaptionskip}{-15pt}
\begin{figure}
\begin{mathpar}
%\hspace{-1cm} %no idea why, but this is better than \centering here
\inferrule* [Right=ptype]
{c_{int} = |\{\forall C \in \trainingSet.\ \forall (k,v) \in C.\ v \in \mathbb{Z}\}| \\\\ c_{bool} = |\{\forall C \in \trainingSet.\ \forall (k,v) \in C.\ v \in \{0,1,ON,OFF\}\}| }
{k : \ptype[int = c_{int}, bool = c_{bool}]}
\and\\
\inferrule* [Right=int]
{k:\ptype \\ p_{int}(\ptype)}
{k :: int}
\and
\inferrule* [Right=bool]
{k:\ptype \\ p_{bool}(\ptype)}
{k :: bool}
\and\\
\inferrule* [Right=eq,before=\hspace{-1.5cm}]
{k_1 :: \tau \\ k_2 :: \tau}
{eq(k_1,k_2) :: Rule}
\and
\inferrule* [Right=order,before=\hspace{-1cm}]
{k1,k2 \in C \\ k1 \neq k2}
{ord(k1,k2) :: Rule}
\end{mathpar}
\caption{Type judgments for a probabilistic type system with $\mathcal{T} = \{bool,int\}$ and an equality and ordering rule}
\label{fig:ptypes}
\end{figure}
}

In order to define resolution predicates, we use the notation $|\tau_{i\ptype}|$ to select $c_i$ from a $\ptype \in \tilde{\mathcal{T}}$.
As an example, for the sample training set provided in Figure~\ref{fig:tset}, we might choose to set $p_{bool}(\ptype)= |bool_{\ptype}| \geq 3 \land |int_{\ptype}| \leq 1$ and $p_{int}(\ptype)= |int_{\ptype}| \geq 3$.
We then can run inference on that sample training set to derive a probabilistic type \texttt{bar}$:[bool=3,int=1]$.
This is then resolved, as required in our earlier example, to \texttt{bar}$::bool$.
 
Note that a user may pick predicates for probabilistic type resolution that result in overlapping inference rules.
For example, if a user instead picked $p_{int}(\ptype)= |int_{\ptype}| \geq 1$, this predicate would overlap with the $p_{bool}$ predicate.
This means that basic types are not unique in this system:  $k::\tau \land k::\tau' \centernot\implies \tau = \tau'$.

In the case that there is not enough evidence to resolve a probabilistic type to a basic type, no type-dependent rules may be learned over that keyword.
However, we are still able to learn rules such as {\scriptsize ORDER}, which do not require any resolved type. 



