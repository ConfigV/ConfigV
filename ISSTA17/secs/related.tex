
\section{Related Work}


%rewritten
\para{Language-support misconfiguration checking}
One approach to statically checking configuration files is to avoid the difficult and unstructured nature of configuration files in the first place.
To that end efforts have introduced special configuration languages that overcome the fundamental deficiencies in the existing untyped or low-level configuration languages. 
For example, network administrators often produce configuration errors in their routing configuration files.
PRESTO~\cite{enck07configuration} introduces configlets as a template language to automates the generation of device-native configurations.
Other work uses Datalog to reason about routing protocols in a declarative fashion~\cite{loo05declarative}. 
COOLAID~\cite{chen10declarative} is a domain specific language to describe knowledge about network devices and services.
In contrast to this approach, our main purpose is to automate configuration verification of existing configuration languages, rather than proposing new, more powerful languages.
This is largely motivated by the unwieldy amount of existing configuration files in industry production.
%Furthermore, new systems are likely to continue to support the simple, unstructured style of existing configuration files beacuse the

Another language based approach is used by ConfValley, a specification language for administrators to provide constraints on their systems' configurations~\cite{huang15confvalley}. 
This approach requires that administrators manually write specifications - an error-prone and difficult process. 
In contrast, by using a learning approach, our work does not require users to manually write any specifications.

\para{Learning}
Using machine learning to tackle misconfiguration detection has also been explored~\cite{yuan11context, zhang14encore, xu16early}.
As an example, EnCore~\cite{zhang14encore} uses a rule learning approach, augmented with user provided templates, to improve the accuracy of their learning results.
The learning process is guided by a set of predefined rule templates that enforce learning to focus on patterns of interest and allow the problem to scale over larger training sets.
EnCore uses the templates to filters out configuration entries that are unlikely to cause errors to reduce false positives.
The templates are also used to directly encode system environment information that would not be contained in the training set for their machine learning.
Compared with EnCore, our approach does not rely on templates - everything is automatically generated.
Furthermore, none of the above approaches use the temporal ordering on the training set inside the learning process.

\para{White-box}
In our approach we assume a ``black-box'' model where we cannot access the system source code.
This is as opposed to a ``white-box'' model, where the source code is available and can leveraged in the configuration analysis.
Although this is a strong assumption, PCheck~\cite{xu16early} explores misconfiguration detection by adding configuration checking code directly in the system source code.
The system is then emulating with various potential configurations of the system.
One drawback to this approach is that for some systems (e.g. ZooKeeper) whose behavior is hard to emulate, PCheck cannot automatically generate the corresponding checking code.
Due to the emulation based testing strategy, PCheck's scope is limited to reliability problems caused by misconfiguration parameters. 
In contrast, our work is a ``black-box'' approach and only requires a training set of configuration files to learn rules.
By using the version space learning strategy of examples, we are also able to detect general misconfiguration issues that are outside the scope of emulation testing (e.g. memory or thread usage settings), including performance, security, availability and reliability.


\iffalse
%TODO rewrite
\para{Misconfiguration diagnosis}
Misconfiguration diagnosis approaches have been proposed to address configuration problems post-mortem.
For example, ConfAid~\cite{attariyan10automating} 
and X-ray~\cite{attariyan12x-ray} use dynamic information
flow tracking to find possible configuration errors that may have resulted in
failures or performance problems. AutoBash~\cite{su07autobash} 
tracks causality and automatically fixes 
misconfigurations. Unlike our work, most misconfiguration
diagnosis efforts aim at finding errors after system
failures occur, which leads to prolonged recovery time.
\fi
